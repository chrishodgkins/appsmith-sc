{
  "animateLoading": true,
  "borderRadius": "{{appsmith.theme.borderRadius.appBorderRadius}}",
  "bottomRow": 241,
  "boxShadow": "{{appsmith.theme.boxShadow.appBoxShadow}}",
  "defaultText": "{{\n  (() => {\n    const content = getconfig.data?.[0]?.config_blob || '';\n    \n    const searchTerm = String(configSearch?.text ?? configSearch ?? '').trim();\n    const lineSearchTerm = String(lineSearch?.text ?? lineSearch ?? '').trim();\n    \n    if (!searchTerm && !lineSearchTerm) {\n      return content;\n    }\n    \n    // Section search only\n    if (searchTerm && !lineSearchTerm) {\n      const startIndex = content.indexOf(searchTerm);\n      if (startIndex === -1) return content;\n      \n      const afterTarget = content.slice(startIndex + searchTerm.length);\n      const nextHeadingMatch = afterTarget.match(/\\n#{1,6}\\s/);\n      \n      const endIndex = nextHeadingMatch \n        ? startIndex + searchTerm.length + nextHeadingMatch.index\n        : content.length;\n      \n      return content.slice(startIndex, endIndex).trim();\n    }\n    \n    // Line search - include subElements when parent matches\n    const lines = content.split('\\n');\n    const result = [];\n    let currentSection = '';\n    let lastAddedSection = '';\n    let inTargetSection = !searchTerm;\n    let currentParentLine = '';\n    let lastAddedParent = '';\n    let includeFollowingIndented = false; // Track if we should include subsequent indented lines\n    \n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      \n      // Track section headers\n      if (line.match(/^#{1,6}\\s/)) {\n        currentSection = line;\n        currentParentLine = '';\n        includeFollowingIndented = false;\n        if (searchTerm) {\n          inTargetSection = line.includes(searchTerm);\n        }\n      }\n      \n      if (searchTerm && !inTargetSection) continue;\n      \n      // Track parent element (non-indented line that's not a code fence)\n      if (line && !line.startsWith(' ') && !line.startsWith('```') && !line.match(/^#{1,6}\\s/)) {\n        currentParentLine = line;\n        includeFollowingIndented = false; // Reset when new parent encountered\n      }\n      \n      // Check if this line matches or should be included\n      const isMatch = line.toLowerCase().includes(lineSearchTerm.toLowerCase()) && \n                      !line.match(/^#{1,6}\\s/) && !line.startsWith('```');\n      const isIndented = line.startsWith(' ');\n      \n      // Include line if:\n      // 1. It matches the search, OR\n      // 2. It's indented and we're including following indented lines (subElements of matched parent)\n      if (isMatch || (isIndented && includeFollowingIndented)) {\n        \n        // Add section header if needed\n        if (currentSection && currentSection !== lastAddedSection) {\n          if (result.length > 0 && result[result.length - 1] !== '```') {\n            result.push('```');\n          }\n          if (result.length > 0) result.push('');\n          result.push(currentSection);\n          result.push('```text');\n          lastAddedSection = currentSection;\n          lastAddedParent = '';\n        }\n        \n        // Add parent element if this is indented and parent not yet added\n        if (isIndented && currentParentLine && currentParentLine !== lastAddedParent) {\n          result.push(currentParentLine);\n          lastAddedParent = currentParentLine;\n          includeFollowingIndented = true; // Enable including following indented lines\n        }\n        \n        // If parent matched, mark to include its subElements\n        if (!isIndented && isMatch) {\n          includeFollowingIndented = true;\n        }\n        \n        result.push(line);\n      } else if (!isIndented) {\n        // Reset flag when we hit a new parent that doesn't match\n        includeFollowingIndented = false;\n      }\n    }\n    \n    // Close final code block\n    if (result.length > 0 && result[result.length - 1] !== '```') {\n      result.push('```');\n    }\n    \n    return result.length > 0 ? result.join('\\n') : content;\n  })()\n}}",
  "dynamicBindingPathList": [
    {
      "key": "borderRadius"
    },
    {
      "key": "boxShadow"
    },
    {
      "key": "defaultText"
    }
  ],
  "dynamicHeight": "FIXED",
  "dynamicTriggerPathList": [],
  "flexVerticalAlignment": "start",
  "inputType": "markdown",
  "isDefaultClickDisabled": true,
  "isDisabled": false,
  "isLoading": false,
  "isRequired": false,
  "isToolbarHidden": false,
  "isVisible": true,
  "key": "6hj04izkhr",
  "labelAlignment": "left",
  "labelPosition": "Top",
  "labelText": "Config",
  "labelTextSize": "0.875rem",
  "labelWidth": 5,
  "leftColumn": 0,
  "maxDynamicHeight": 9000,
  "minDynamicHeight": 4,
  "minWidth": 450,
  "mobileBottomRow": 26,
  "mobileLeftColumn": 1,
  "mobileRightColumn": 25,
  "mobileTopRow": 6,
  "needsErrorInfo": false,
  "parentColumnSpace": 6.9375,
  "parentId": "xezuhduakt",
  "parentRowSpace": 10,
  "renderMode": "CANVAS",
  "responsiveBehavior": "fill",
  "rightColumn": 63,
  "shouldScrollContents": true,
  "topRow": 8,
  "type": "RICH_TEXT_EDITOR_WIDGET",
  "version": 1,
  "widgetId": "p4qwp8sdax",
  "widgetName": "RichTextEditor1"
}