{
  "backgroundColor": "#FFFFFF",
  "borderColor": "#E0DEDE",
  "borderRadius": "{{appsmith.theme.borderRadius.appBorderRadius}}",
  "borderWidth": "1",
  "bottomRow": 82,
  "boxShadow": "{{appsmith.theme.boxShadow.appBoxShadow}}",
  "defaultModel": "{{NetworkData.getCustomerData()}}",
  "dynamicBindingPathList": [
    {
      "key": "theme"
    },
    {
      "key": "borderRadius"
    },
    {
      "key": "boxShadow"
    },
    {
      "key": "defaultModel"
    },
    {
      "key": "isVisible"
    }
  ],
  "dynamicHeight": "FIXED",
  "dynamicPropertyPathList": [
    {
      "key": "isVisible"
    }
  ],
  "dynamicTriggerPathList": [
    {
      "key": "onResetClick"
    }
  ],
  "events": [
    "onResetClick"
  ],
  "isCanvas": false,
  "isLoading": false,
  "isSearchWildcard": true,
  "isVisible": "{{appsmith.store.statclickaccount !== ''}}",
  "key": "y4iizptz7z",
  "leftColumn": 21,
  "maxDynamicHeight": 9000,
  "minDynamicHeight": 4,
  "mobileBottomRow": 38,
  "mobileLeftColumn": 30,
  "mobileRightColumn": 53,
  "mobileTopRow": 8,
  "needsErrorInfo": false,
  "onResetClick": "{{showAlert('Successfully reset!!', '');}}",
  "originalBottomRow": 79,
  "originalTopRow": 8,
  "parentColumnSpace": 18.460205078125,
  "parentId": "yaeuqx8gh2",
  "parentRowSpace": 10,
  "renderMode": "CANVAS",
  "rightColumn": 64,
  "srcDoc": {
    "css": "/* ============================================================================\n   DATA TOPOLOGY V1 - CSS STYLES FOR APPSMITH WIDGET\n   ============================================================================\n\n   This CSS file contains all styling for the dataTopoV1 network topology\n   React Flow diagram, including custom node types and layout.\n\n   Copy this content into the \"CSS\" tab of your Custom Widget Builder.\n\n   ============================================================================ */\n/* ============================================================================\n   SECTION 1: Container Reset & Layout\n   ============================================================================ */\n/* Function 1.1: Reset default styles and ensure full viewport */\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\n/* Function 1.2: Root container takes full widget space */\n#root {\n  width: 100%;\n  height: 100%;\n  min-height: 600px;\n  position: relative;\n  overflow: hidden;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\", \"Ubuntu\", \"Cantarell\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\", sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n/* ============================================================================\n   SECTION 2: React Flow Specific Overrides\n   ============================================================================ */\n/* Function 2.1: Ensure React Flow container fills space */\n.react-flow {\n  width: 100% !important;\n  height: 100% !important;\n}\n\n/* Function 2.2: Style minimap for better visibility */\n.react-flow__minimap {\n  background-color: #f9fafb;\n  border: 1px solid #e5e7eb;\n  border-radius: 4px;\n}\n\n/* Function 2.3: Style controls panel */\n.react-flow__controls {\n  background-color: white;\n  border: 1px solid #e5e7eb;\n  border-radius: 6px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n/* Function 2.4: Style control buttons */\n.react-flow__controls-button {\n  border-bottom: 1px solid #e5e7eb;\n  background-color: white;\n  transition: background-color 0.2s;\n}\n\n.react-flow__controls-button:hover {\n  background-color: #f3f4f6;\n}\n\n.react-flow__controls-button:last-child {\n  border-bottom: none;\n}\n\n/* ============================================================================\n   SECTION 3: Custom Node Types - Standard Node\n   ============================================================================ */\n/* Function 3.1: Custom node base styling */\n.custom-node {\n  padding: 10px 20px;\n  border-radius: 5px;\n  border: 2px solid #1a192b;\n  min-width: 100px;\n  min-height: 50px;\n  width: 100%;\n  height: 100%;\n  text-align: center;\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: #ffffff;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  transition: box-shadow 0.2s;\n}\n\n.custom-node:hover {\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);\n}\n\n.custom-node-content {\n  font-size: 14px;\n  color: #222;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  word-wrap: break-word;\n  padding: 5px;\n}\n\n/* Function 3.2: Node selection highlighting */\n.react-flow__node.selected .custom-node {\n  box-shadow: 0 0 0 3px #3b82f6;\n}\n\n/* ============================================================================\n   SECTION 4: Custom Node Types - Group Node\n   ============================================================================ */\n/* Function 4.1: Custom group node for containers */\n.custom-group-node {\n  width: 100%;\n  height: 100%;\n  background: rgba(240, 240, 255, 0.25);\n  border: 2px dashed #4299e1;\n  border-radius: 8px;\n  position: relative;\n  padding: 10px;\n  pointer-events: none;\n}\n\n.custom-group-node-label {\n  position: absolute;\n  top: 5px;\n  left: 10px;\n  font-size: 14px;\n  font-weight: 600;\n  color: #2d3748;\n  background: rgba(255, 255, 255, 0.9);\n  padding: 4px 8px;\n  border-radius: 4px;\n  border: 1px solid #cbd5e0;\n  z-index: 10;\n  pointer-events: all;\n}\n\n/* ============================================================================\n   SECTION 5: Custom Node Types - Text Node\n   ============================================================================ */\n/* Function 5.1: Custom text node for annotations */\n.custom-text-node {\n  padding: 12px;\n  border-radius: 4px;\n  border: 1px solid #cbd5e0;\n  min-width: 150px;\n  min-height: 100px;\n  width: 100%;\n  height: 100%;\n  position: relative;\n  display: flex;\n  align-items: flex-start;\n  justify-content: flex-start;\n  background: #fffef0;\n}\n\n.custom-text-node-content {\n  font-size: 13px;\n  color: #222;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  overflow-wrap: break-word;\n  padding: 5px;\n  width: 100%;\n  height: 100%;\n  overflow-y: auto;\n  line-height: 1.5;\n  text-align: left;\n}\n\n/* ============================================================================\n   SECTION 6: Handle (Connection Point) Styling\n   ============================================================================ */\n/* Function 6.1: Base handle styling for all nodes */\n.react-flow__handle {\n  width: 10px;\n  height: 10px;\n  border-radius: 50%;\n  background: #555;\n  border: 2px solid white;\n  transition: all 0.2s;\n}\n\n.custom-node .react-flow__handle,\n.custom-group-node .react-flow__handle,\n.custom-text-node .react-flow__handle {\n  width: 10px;\n  height: 10px;\n  border-radius: 50%;\n  border: 2px solid white;\n}\n\n.custom-node .react-flow__handle {\n  background: #555;\n}\n\n.custom-group-node .react-flow__handle {\n  background: #4299e1;\n  pointer-events: all;\n}\n\n.custom-text-node .react-flow__handle {\n  background: #555;\n}\n\n/* Function 6.2: Handle position adjustments */\n.react-flow__handle-top {\n  top: -6px;\n}\n\n.react-flow__handle-bottom {\n  bottom: -6px;\n}\n\n.react-flow__handle-left {\n  left: -6px;\n}\n\n.react-flow__handle-right {\n  right: -6px;\n}\n\n/* Function 6.3: Handle hover state */\n.react-flow__handle:hover {\n  background-color: #3b82f6;\n  transform: scale(1.2);\n}\n\n/* Function 6.4: Handle connection state */\n.react-flow__handle-connecting {\n  background-color: #10b981;\n}\n\n/* Function 6.5: Valid connection target */\n.react-flow__handle-valid {\n  background-color: #10b981;\n}\n\n/* ============================================================================\n   SECTION 7: Edge (Connection) Styling\n   ============================================================================ */\n/* Function 7.1: Edge label styling */\n.react-flow__edge-text {\n  font-size: 11px;\n  font-weight: 600;\n  fill: #374151;\n}\n\n/* Function 7.1b: Edge label foreignObject styling for HTML labels */\n.react-flow__edge foreignObject {\n  overflow: visible;\n}\n\n.react-flow__edge foreignObject > div {\n  transform: translate(-50%, -50%);\n}\n\n/* Function 7.1c: Edge label background */\n.react-flow__edge-textbg {\n  fill: rgba(255, 255, 255, 0.9);\n  rx: 4;\n  ry: 4;\n}\n\n/* Function 7.2: Connection line preview */\n.react-flow__connection-path {\n  stroke: #6366f1;\n  stroke-width: 2;\n}\n\n/* Function 7.3: Selected edge highlighting */\n.react-flow__edge.selected .react-flow__edge-path {\n  stroke: #3b82f6;\n  stroke-width: 3;\n}\n\n/* ============================================================================\n   SECTION 8: Background & Grid\n   ============================================================================ */\n/* Function 8.1: Background pattern styling */\n.react-flow__background {\n  background-color: #ffffff;\n}\n\n/* Function 8.2: Grid dot styling */\n.react-flow__background-pattern {\n  fill: #e5e7eb;\n}\n\n/* ============================================================================\n   SECTION 9: Node Resizer Styling\n   ============================================================================ */\n/* Function 9.1: Custom node resizer */\n.custom-node-resizer-line {\n  border-color: #4299e1 !important;\n  border-width: 2px !important;\n}\n\n.custom-node-resizer-handle {\n  width: 10px !important;\n  height: 10px !important;\n  border-radius: 2px !important;\n  background-color: #4299e1 !important;\n}\n\n/* Function 9.2: Group node resizer */\n.custom-group-resizer-line {\n  border-color: #3182ce !important;\n  border-width: 2px !important;\n  border-style: solid !important;\n  pointer-events: all !important;\n}\n\n.custom-group-resizer-handle {\n  width: 12px !important;\n  height: 12px !important;\n  border-radius: 2px !important;\n  background-color: #3182ce !important;\n  pointer-events: all !important;\n}\n\n.custom-group-node .react-flow__resize-control {\n  pointer-events: all !important;\n}\n\n/* Function 9.3: Text node resizer */\n.custom-text-node-resizer-line {\n  border-color: #4299e1 !important;\n  border-width: 2px !important;\n}\n\n.custom-text-node-resizer-handle {\n  width: 10px !important;\n  height: 10px !important;\n  border-radius: 2px !important;\n  background-color: #4299e1 !important;\n}\n\n/* ============================================================================\n   SECTION 10: Loading & Error States\n   ============================================================================ */\n/* Function 10.1: Loading indicator */\n.topology-loading {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", sans-serif;\n  color: #6b7280;\n  font-size: 14px;\n}\n\n/* Function 10.2: Error message styling */\n.topology-error {\n  padding: 20px;\n  color: #ef4444;\n  font-family: monospace;\n  background-color: #fef2f2;\n  border: 1px solid #fecaca;\n  border-radius: 6px;\n  margin: 20px;\n  font-size: 13px;\n}\n\n.topology-error h3 {\n  margin-bottom: 10px;\n  color: #dc2626;\n}\n\n.topology-error pre {\n  background: #f5f5f5;\n  padding: 10px;\n  overflow: auto;\n  border-radius: 4px;\n  font-size: 11px;\n}\n\n/* ============================================================================\n   SECTION 11: Utility Classes\n   ============================================================================ */\n/* Function 11.1: Text utilities */\n.text-center {\n  text-align: center;\n}\n\n.text-left {\n  text-align: left;\n}\n\n.pre-line {\n  white-space: pre-line;\n}\n\n/* Function 11.2: Spacing utilities */\n.p-20 {\n  padding: 20px;\n}\n\n.m-20 {\n  margin: 20px;\n}",
    "html": "<!-- ============================================================================\n     DATA TOPOLOGY V1 - HTML COMPONENT FOR APPSMITH\n     ============================================================================\n\n     This is the HTML section of the Appsmith Custom Widget for the\n     dataTopoV1 network topology diagram.\n\n     Copy this content into the \"HTML\" tab of your Custom Widget Builder.\n\n     Components:\n     1. Root container for React rendering\n     2. Import map for ESM module resolution\n     3. React Flow CSS stylesheet\n\n     ============================================================================\n-->\n\n<!-- Root Container -->\n<div id=\"root\" style=\"width: 100%; height: 800px;\"></div>\n\n<!-- React Flow CSS -->\n<link\n  href=\"https://cdn.jsdelivr.net/npm/reactflow@11.11.4/dist/style.min.css\"\n  rel=\"stylesheet\"\n/>\n",
    "js": "/* ============================================================================\n * DATA TOPOLOGY V1 - APPSMITH CUSTOM WIDGET JAVASCRIPT\n * ============================================================================\n *\n * Project: Network Topology Visualization with React Flow\n * Template: dataTopoV1 (Auto-generated flow)\n * Created: November 2025\n *\n * Purpose: Interactive network topology diagram using React Flow with\n * custom node types (CustomNode, CustomGroupNode, CustomTextNode)\n *\n * Appsmith Integration:\n * - Uses appsmith.onReady() for initialization\n * - Supports dynamic data updates via appsmith.model\n * - ESM module imports for React and React Flow\n *\n * Copy this content into the \"JS\" tab of your Custom Widget Builder.\n *\n * ============================================================================\n */\n\n/* ========================================================================\n * APPSMITH INITIALIZATION\n * ========================================================================\n */\n\nappsmith.onReady(() => {\n  console.log(\"=== DataTopoV1 Network Topology Initializing ===\");\n\n  // Main initialization function\n  initializeNetworkTopology();\n});\n\n/* ========================================================================\n * MAIN INITIALIZATION FUNCTION\n * ========================================================================\n */\n\nasync function initializeNetworkTopology() {\n  try {\n    /* STEP 1: Import React Libraries - Share same instance globally */\n    if (!window.React) {\n      window.React = await import(\"https://esm.sh/react@18.3.1\");\n    }\n    if (!window.ReactDOM) {\n      window.ReactDOM = await import(\"https://esm.sh/react-dom@18.3.1\");\n    }\n    const React = window.React;\n    const ReactDOMClient = await import(\"https://esm.sh/react-dom@18.3.1/client\");\n\n    // Import ReactFlow with pinned React version\n    const ReactFlowModule = await import(\"https://esm.sh/reactflow@11.11.4?deps=react@18.3.1,react-dom@18.3.1&bundle\");\n    const {\n      default: ReactFlow,\n      Controls,\n      Background,\n      MiniMap,\n      Handle,\n      Position,\n      NodeResizer,\n      ReactFlowProvider,\n      getBezierPath,\n      EdgeLabelRenderer,\n      BaseEdge\n    } = ReactFlowModule;\n    console.log(\"âœ“ React and React Flow modules loaded\");\n    console.log(\"ReactFlowProvider available:\", typeof ReactFlowProvider);\n\n    /* ====================================================================\n     * CUSTOM EDGE COMPONENT\n     * ====================================================================\n     */\n\n    /* COMPONENT: CarrierConnectionEdge - Edge for carrier connections with comma-based wrapping */\n    const CarrierConnectionEdge = ({\n      id,\n      sourceX,\n      sourceY,\n      targetX,\n      targetY,\n      sourcePosition,\n      targetPosition,\n      style = {},\n      data\n    }) => {\n      const [edgePath, labelX, labelY] = getBezierPath({\n        sourceX,\n        sourceY,\n        sourcePosition,\n        targetX,\n        targetY,\n        targetPosition\n      });\n\n      // Helper function to wrap text only at commas with max width\n      const wrapAtCommas = (text, maxWidth = 200) => {\n        if (!text) return [];\n        const items = text.split(\",\").map(item => item.trim());\n        const lines = [];\n        let currentLine = \"\";\n        items.forEach((item, index) => {\n          const isLast = index === items.length - 1;\n          const itemWithComma = isLast ? item : item + \",\";\n\n          // Estimate character width (roughly 6-7px per char at 11px font)\n          const estimatedWidth = (currentLine + \" \" + itemWithComma).length * 7;\n          if (currentLine === \"\") {\n            currentLine = itemWithComma;\n          } else if (estimatedWidth <= maxWidth) {\n            currentLine += \" \" + itemWithComma;\n          } else {\n            lines.push(currentLine);\n            currentLine = itemWithComma;\n          }\n        });\n        if (currentLine) lines.push(currentLine);\n        return lines;\n      };\n      const labelLines = data?.label ? wrapAtCommas(data.label, data.maxWidth || 200) : [];\n      return React.createElement(React.Fragment, null, React.createElement(BaseEdge, {\n        path: edgePath,\n        style: style\n      }), labelLines.length > 0 && React.createElement(EdgeLabelRenderer, null, React.createElement(\"div\", {\n        style: {\n          position: \"absolute\",\n          transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n          background: \"rgba(255, 255, 255, 0.95)\",\n          padding: \"6px 10px\",\n          borderRadius: \"4px\",\n          fontSize: \"11px\",\n          border: \"1px solid #e5e7eb\",\n          lineHeight: \"1.5\",\n          whiteSpace: \"nowrap\",\n          textAlign: \"left\",\n          boxShadow: \"0 1px 3px rgba(0,0,0,0.1)\",\n          fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", sans-serif',\n          pointerEvents: \"all\",\n          maxWidth: `${data.maxWidth || 200}px`\n        },\n        className: \"nodrag nopan\"\n      }, labelLines.map((line, idx) => React.createElement(\"div\", {\n        key: idx\n      }, line)))));\n    };\n\n    /* COMPONENT: CustomEdge - Edge with multi-line label */\n    const CustomEdge = ({\n      id,\n      sourceX,\n      sourceY,\n      targetX,\n      targetY,\n      sourcePosition,\n      targetPosition,\n      style = {},\n      data\n    }) => {\n      const [edgePath, labelX, labelY] = getBezierPath({\n        sourceX,\n        sourceY,\n        sourcePosition,\n        targetX,\n        targetY,\n        targetPosition\n      });\n\n      // Helper function to wrap text at max character length\n      const wrapText = (text, maxLength = 60) => {\n        if (!text || text.length <= maxLength) return [text];\n        const lines = [];\n        let currentLine = \"\";\n        const words = text.split(\" \");\n        for (const word of words) {\n          if ((currentLine + \" \" + word).trim().length <= maxLength) {\n            currentLine = currentLine ? currentLine + \" \" + word : word;\n          } else {\n            if (currentLine) lines.push(currentLine);\n            currentLine = word;\n          }\n        }\n        if (currentLine) lines.push(currentLine);\n        return lines;\n      };\n\n      // Wrap each line if needed\n      const line1Parts = data?.label?.line1 ? wrapText(data.label.line1) : [];\n      const line2Parts = data?.label?.line2 ? wrapText(data.label.line2) : [];\n      const line3Parts = data?.label?.line3 ? wrapText(data.label.line3) : [];\n      return React.createElement(React.Fragment, null, React.createElement(BaseEdge, {\n        path: edgePath,\n        style: style\n      }), data && data.label && React.createElement(EdgeLabelRenderer, null, React.createElement(\"div\", {\n        style: {\n          position: \"absolute\",\n          transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n          background: \"rgba(255, 255, 255, 0.95)\",\n          padding: \"6px 10px\",\n          borderRadius: \"4px\",\n          fontSize: \"11px\",\n          border: \"1px solid #e5e7eb\",\n          lineHeight: \"1.5\",\n          whiteSpace: \"pre-wrap\",\n          textAlign: \"left\",\n          boxShadow: \"0 1px 3px rgba(0,0,0,0.1)\",\n          fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", sans-serif',\n          pointerEvents: \"all\",\n          maxWidth: \"300px\"\n        },\n        className: \"nodrag nopan\"\n      }, line1Parts.map((part, idx) => React.createElement(\"div\", {\n        key: `line1-${idx}`\n      }, part)), line2Parts.map((part, idx) => React.createElement(\"div\", {\n        key: `line2-${idx}`\n      }, part)), line3Parts.map((part, idx) => React.createElement(\"div\", {\n        key: `line3-${idx}`\n      }, part)))));\n    };\n\n    /* ====================================================================\n     * CUSTOM NODE COMPONENTS\n     * ====================================================================\n     */\n\n    /* COMPONENT 1: CustomNode - Standard resizable node with handles */\n    const CustomNode = ({\n      data,\n      isConnectable,\n      selected\n    }) => {\n      const labelText = String(data?.label || \"\");\n\n      // Split label by newlines and create separate divs for each line\n      const labelLines = labelText.split(\"\\n\").map((line, index) => React.createElement(\"div\", {\n        key: index\n      }, line));\n      return React.createElement(\"div\", {\n        className: \"custom-node\"\n      }, React.createElement(NodeResizer, {\n        minWidth: 100,\n        minHeight: 50,\n        isVisible: selected\n      }), React.createElement(Handle, {\n        type: \"target\",\n        position: Position.Top,\n        id: \"top\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"target\",\n        position: Position.Left,\n        id: \"left\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"target\",\n        position: Position.Right,\n        id: \"right\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"target\",\n        position: Position.Bottom,\n        id: \"bottom\",\n        isConnectable\n      }), React.createElement(\"div\", {\n        className: \"custom-node-content\"\n      }, ...labelLines), React.createElement(Handle, {\n        type: \"source\",\n        position: Position.Top,\n        id: \"top-source\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"source\",\n        position: Position.Left,\n        id: \"left-source\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"source\",\n        position: Position.Right,\n        id: \"right-source\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"source\",\n        position: Position.Bottom,\n        id: \"bottom-source\",\n        isConnectable\n      }));\n    };\n\n    /* COMPONENT 2: CustomGroupNode - Group/container node */\n    const CustomGroupNode = ({\n      data,\n      isConnectable,\n      selected\n    }) => {\n      const labelText = String(data?.label || \"\");\n      return React.createElement(\"div\", {\n        className: \"custom-group-node\"\n      }, React.createElement(NodeResizer, {\n        minWidth: 200,\n        minHeight: 150,\n        isVisible: selected\n      }), React.createElement(Handle, {\n        type: \"target\",\n        position: Position.Top,\n        id: \"top\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"target\",\n        position: Position.Left,\n        id: \"left\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"target\",\n        position: Position.Right,\n        id: \"right\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"target\",\n        position: Position.Bottom,\n        id: \"bottom\",\n        isConnectable\n      }), React.createElement(\"div\", {\n        className: \"custom-group-node-label\"\n      }, labelText), React.createElement(Handle, {\n        type: \"source\",\n        position: Position.Top,\n        id: \"top-source\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"source\",\n        position: Position.Left,\n        id: \"left-source\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"source\",\n        position: Position.Right,\n        id: \"right-source\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"source\",\n        position: Position.Bottom,\n        id: \"bottom-source\",\n        isConnectable\n      }));\n    };\n\n    /* COMPONENT 3: CustomTextNode - Text/annotation node */\n    const CustomTextNode = ({\n      data,\n      isConnectable,\n      selected\n    }) => {\n      const labelText = String(data?.label || \"\");\n      const isHtml = data?.isHtml || false;\n      return React.createElement(\"div\", {\n        className: \"custom-text-node\"\n      }, React.createElement(NodeResizer, {\n        minWidth: 150,\n        minHeight: 100,\n        isVisible: selected\n      }), React.createElement(Handle, {\n        type: \"target\",\n        position: Position.Top,\n        id: \"top\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"target\",\n        position: Position.Left,\n        id: \"left\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"target\",\n        position: Position.Right,\n        id: \"right\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"target\",\n        position: Position.Bottom,\n        id: \"bottom\",\n        isConnectable\n      }), React.createElement(\"div\", {\n        className: \"custom-text-node-content\",\n        ...(isHtml ? {\n          dangerouslySetInnerHTML: {\n            __html: labelText\n          }\n        } : {})\n      }, isHtml ? null : labelText), React.createElement(Handle, {\n        type: \"source\",\n        position: Position.Top,\n        id: \"top-source\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"source\",\n        position: Position.Left,\n        id: \"left-source\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"source\",\n        position: Position.Right,\n        id: \"right-source\",\n        isConnectable\n      }), React.createElement(Handle, {\n        type: \"source\",\n        position: Position.Bottom,\n        id: \"bottom-source\",\n        isConnectable\n      }));\n    };\n\n    /* ====================================================================\n     * NETWORK TOPOLOGY DATA - dataTopoV1\n     * ====================================================================\n     */\n\n    /* HELPER: Convert Markdown Table to HTML */\n    function markdownTableToHtml(markdown) {\n      if (!markdown || typeof markdown !== \"string\") return \"\";\n      const lines = markdown.trim().split(\"\\n\").filter(line => line.trim());\n      if (lines.length === 0) return \"\";\n\n      // Column headers based on position\n      const columnHeaders = [\"SBC\", \"From_Range\", \"To_Range\", \"Status\", \"Source_Realm\", \"Next_Hop\", \"Dest_Realm\"];\n      let html = '<table style=\"width: 100%; border-collapse: collapse; font-size: 11px;\">';\n      let headerAdded = false;\n\n      // Process each line\n      lines.forEach((line, index) => {\n        // Skip separator line (contains dashes)\n        if (line.includes(\"---\") || line.includes(\"|-\")) return;\n\n        // Split by pipe and clean up - remove > and < characters\n        const cells = line.split(\"|\").map(cell => cell.trim().replace(/[><]/g, \"\")).filter(cell => cell);\n        if (cells.length === 0) return;\n\n        // Add header on first data line\n        if (!headerAdded) {\n          html += '<thead><tr style=\"background: #f3f4f6; font-weight: 600;\">';\n\n          // Use column headers based on number of columns in data\n          const numColumns = cells.length;\n          for (let i = 0; i < numColumns && i < columnHeaders.length; i++) {\n            html += `<th style=\"border: 1px solid #d1d5db; padding: 6px 8px; text-align: left;\">${columnHeaders[i]}</th>`;\n          }\n          html += \"</tr></thead><tbody>\";\n          headerAdded = true;\n        }\n\n        // Add data row\n        html += \"<tr>\";\n        cells.forEach(cell => {\n          html += `<td style=\"border: 1px solid #d1d5db; padding: 6px 8px;\">${cell}</td>`;\n        });\n        html += \"</tr>\";\n      });\n      html += \"</tbody></table>\";\n      return html;\n    }\n\n    /* HELPER: Update Local Policy Text Nodes */\n    function updateLocalPolicyNodes(baseNodes) {\n      // Get customer data from appsmith model or use empty array\n      const customerData = typeof appsmith !== \"undefined\" && appsmith.model?.customerData ? appsmith.model.customerData : [];\n\n      // Get local policy summary for SYD1A\n      const syd1PolicyData = customerData.find(c => c.data_source === \"SYD1A\" && c.local_policy_summary);\n      return baseNodes.map(node => {\n        // Update Local Policy SYD1 text node (text-22)\n        if (node.id === \"text-22\" && syd1PolicyData?.local_policy_summary) {\n          const htmlTable = markdownTableToHtml(syd1PolicyData.local_policy_summary);\n          const accountNo = syd1PolicyData.account_no || \"\";\n          return {\n            ...node,\n            data: {\n              ...node.data,\n              label: htmlTable,\n              isHtml: true // Flag to render as HTML\n            }\n          };\n        }\n        return node;\n      });\n    }\n\n    /* HELPER: Enhance DataCentre Nodes with SIP Interface IPs */\n    function enhanceDataCentreNodes(baseNodes) {\n      // Get customer data from appsmith model or use empty array\n      const customerData = typeof appsmith !== \"undefined\" && appsmith.model?.customerData ? appsmith.model.customerData : [];\n\n      // Map data_source to node IDs\n      const dataSourceToNodeId = {\n        SYD1A: \"19\",\n        SYD2A: \"21\",\n        SEMA: \"20\"\n      };\n\n      // Check if customer uses SEMA payments\n      const usesSemaPayments = customerData.some(customer => customer.uses_sema_payments === true || customer.uses_sema_payments === \"true\");\n      console.log(\"Customer uses SEMA payments:\", usesSemaPayments);\n\n      // Collect SIP interface IPs by data source\n      const sipInterfacesByNode = {};\n      customerData.forEach(customer => {\n        if (customer.data_source && customer.sip_interface_ips) {\n          const nodeId = dataSourceToNodeId[customer.data_source];\n          if (nodeId) {\n            if (!sipInterfacesByNode[nodeId]) {\n              sipInterfacesByNode[nodeId] = new Set();\n            }\n            // Add IPs to the set (automatically deduplicates)\n            const ips = customer.sip_interface_ips.split(\",\").map(ip => ip.trim());\n            ips.forEach(ip => sipInterfacesByNode[nodeId].add(ip));\n          }\n        }\n      });\n\n      // Update node labels with SIP interface IPs and grey out SEMA if not used\n      return baseNodes.map(node => {\n        let updatedNode = {\n          ...node\n        };\n\n        // Add SIP interfaces if available\n        if (sipInterfacesByNode[node.id]) {\n          const ips = Array.from(sipInterfacesByNode[node.id]).join(\", \");\n          const originalLabel = node.data.label;\n          updatedNode = {\n            ...updatedNode,\n            data: {\n              ...updatedNode.data,\n              label: `${originalLabel}\\nSIP Interfaces: ${ips}`\n            }\n          };\n        }\n\n        // Grey out SEMA node if not using SEMA payments\n        if (node.id === \"20\" && !usesSemaPayments) {\n          updatedNode = {\n            ...updatedNode,\n            style: {\n              ...updatedNode.style,\n              backgroundColor: \"#d1d5db\",\n              // Grey color\n              opacity: 0.6\n            }\n          };\n        }\n        return updatedNode;\n      });\n    }\n\n    /* HELPER: Generate IVP Customer Nodes from appsmith data */\n    function generateIVPCustomerNodes() {\n      const customerNodes = [];\n\n      // Get customer data from appsmith model or use empty array\n      const customerData = typeof appsmith !== \"undefined\" && appsmith.model?.customerData ? appsmith.model.customerData : [];\n      console.log(\"=== IVP Customer Data ===\");\n      console.log(\"Total customer records:\", customerData.length);\n      if (customerData.length > 0) {\n        console.log(\"Sample customer fields:\", Object.keys(customerData[0]));\n\n        // Check for all IVP-related fields\n        const ivpFields = Object.keys(customerData[0]).filter(key => key.toLowerCase().includes(\"ivp\"));\n        console.log(\"IVP-related field names found:\", ivpFields);\n\n        // Log values of IVP fields\n        ivpFields.forEach(field => {\n          console.log(`Sample ${field}:`, customerData[0][field]);\n        });\n\n        // Also check specifically for the fields we're looking for\n        console.log(\"Sample ivp_region_name:\", customerData[0].ivp_region_name);\n        console.log(\"Sample ivp_inbound_uri:\", customerData[0].ivp_inbound_uri);\n        console.log(\"Sample ivp_outbound_uri:\", customerData[0].ivp_outbound_uri);\n        console.log(\"Sample ivp_svccarriages:\", customerData[0].ivp_svccarriages);\n      }\n\n      // Filter for IVP customers (those with \"Region Name\" field)\n      const ivpCustomersAll = customerData.filter(c => c[\"Region Name\"] && c.account_no);\n\n      // Deduplicate by account_no to avoid duplicate services\n      const seenAccounts = new Set();\n      const ivpCustomers = ivpCustomersAll.filter(c => {\n        if (seenAccounts.has(c.account_no)) {\n          return false;\n        }\n        seenAccounts.add(c.account_no);\n        return true;\n      });\n      console.log(\"IVP records found (deduplicated):\", ivpCustomers.length);\n\n      // If no IVP customers found, check for truthy \"Region Name\" values\n      if (ivpCustomers.length === 0) {\n        const customersWithIvpRegion = customerData.filter(c => c[\"Region Name\"]);\n        console.log('Customers with \"Region Name\" (any value):', customersWithIvpRegion.length);\n        if (customersWithIvpRegion.length > 0) {\n          console.log('Sample \"Region Name\" values:', customersWithIvpRegion.slice(0, 3).map(c => c[\"Region Name\"]));\n        }\n      }\n      if (ivpCustomers.length === 0) {\n        console.log(\"No IVP customers to display - checking for null/undefined ivp_region_name\");\n        return customerNodes;\n      }\n\n      // Get IVP services lookup data from model\n      const ivpServicesLookup = typeof appsmith !== \"undefined\" && appsmith.model?.ivpServices ? appsmith.model.ivpServices : [];\n      console.log(`IVP Services lookup data available: ${ivpServicesLookup.length} records`);\n\n      // First, count total number of IVP service nodes to calculate centering\n      // Build array of all services by matching externalid\n      let allServices = [];\n      ivpCustomers.forEach(customer => {\n        const externalId = customer.ivp_externalid;\n        if (!externalId) return;\n\n        // Find all services for this customer by externalid\n        const customerServices = ivpServicesLookup.filter(svc => svc.externalid === externalId);\n\n        // Sort services by Region Name (AU1 first, then AU2)\n        customerServices.sort((a, b) => {\n          const regionA = a[\"Region Name\"] || \"\";\n          const regionB = b[\"Region Name\"] || \"\";\n          if (regionA === regionB) return 0;\n          if (regionA === \"AU1\") return -1;\n          if (regionB === \"AU1\") return 1;\n          return regionA.localeCompare(regionB);\n        });\n        allServices.push({\n          customer: customer,\n          services: customerServices\n        });\n      });\n      const totalServiceCount = allServices.reduce((sum, item) => sum + item.services.length, 0);\n\n      // Calculate vertical centering based on IVP Cloud container\n      // IVP Cloud container (group-9) absolute position and size\n      const ivpCloudY = -259.73;\n      const ivpCloudHeight = 239;\n      const ivpCloudCenter = ivpCloudY + ivpCloudHeight / 2;\n      const nodeHeight = 120;\n      const nodeSpacing = 130; // Spacing between node positions (120px node + 10px gap)\n\n      // Calculate the span from first node top to last node bottom\n      // First to last node position span: (N-1) * spacing\n      // Plus the height of the last node: + nodeHeight\n      // Total span = (N-1) * spacing + nodeHeight\n      const totalSpan = (totalServiceCount - 1) * nodeSpacing + nodeHeight;\n\n      // Center the block of nodes at the IVP Cloud center\n      // Top of first node = ivpCloudCenter - (totalSpan / 2)\n      const centerOffset = ivpCloudCenter - totalSpan / 2;\n      console.log(`IVP Cloud Y: ${ivpCloudY}, Height: ${ivpCloudHeight}, Center: ${ivpCloudCenter}`);\n      console.log(`Total IVP service nodes: ${totalServiceCount}, center offset: ${centerOffset}, IVP Cloud center: ${ivpCloudCenter}`);\n\n      // Create separate nodes for each IVP service from ivpServices\n      let nodeCounter = 0;\n      allServices.forEach(item => {\n        const customer = item.customer;\n        const services = item.services;\n        console.log(`Processing IVP customer: ${customer.customer} (${customer.account_no})`);\n        console.log(`  External ID: ${customer.ivp_externalid}`);\n        console.log(`  Found ${services.length} services in ivpServices lookup`);\n\n        // Parse ivp_svcSIP to get profile labels for each service\n        let svcSIPData = [];\n        if (customer.ivp_svcSIP) {\n          try {\n            const svcSIP = JSON.parse(customer.ivp_svcSIP);\n            if (Array.isArray(svcSIP)) {\n              svcSIPData = svcSIP;\n            }\n          } catch (e) {\n            console.error(\"Error parsing ivp_svcSIP:\", e);\n          }\n        }\n\n        // Create a node for each service from ivpServices\n        services.forEach((service, index) => {\n          const serviceName = service[\"Service name\"] || \"N/A\";\n          const inboundUri = service[\"Inbound server/uri\"] || \"N/A\";\n\n          // Find matching profile label from ivp_svcSIP\n          let profileLabel = \"\";\n          const matchingSvc = svcSIPData.find(svc => svc.name === serviceName);\n          if (matchingSvc && matchingSvc.profile) {\n            profileLabel = matchingSvc.profile.label || \"\";\n          }\n\n          // Use index-based ID to match edge generation\n          const nodeId = `ivp-customer-${customer.account_no}-${index}`;\n          console.log(`  Creating IVP node: ${serviceName} | Profile: ${profileLabel} | Inbound: ${inboundUri}`);\n          customerNodes.push({\n            id: nodeId,\n            type: \"custom\",\n            data: {\n              label: `${customer.customer}\\n${serviceName}\\n${profileLabel}\\n${inboundUri}`\n            },\n            position: {\n              x: 1000,\n              y: centerOffset + nodeCounter * nodeSpacing\n            },\n            style: {\n              width: 350,\n              height: 120,\n              // Taller for 4 lines of text\n              backgroundColor: \"#dbeafe\" // Light blue for IVP\n            }\n          });\n          nodeCounter++;\n        });\n      });\n      console.log(\"IVP customer nodes created:\", customerNodes.length);\n      return customerNodes;\n    }\n\n    /* HELPER: Generate Gen1 Customer Nodes from appsmith data */\n    function generateGen1CustomerNodes() {\n      const customerNodes = [];\n\n      // Get customer data from appsmith model or use empty array\n      const customerData = typeof appsmith !== \"undefined\" && appsmith.model?.customerData ? appsmith.model.customerData : [];\n      console.log(\"=== Gen1 Customer Data ===\");\n      console.log(\"Total records:\", customerData.length);\n      console.log(\"Sample record:\", customerData[0]);\n\n      // Filter for Gen1 customers (those with data_source field)\n      const gen1Customers = customerData.filter(c => c.data_source && c.account_no);\n      console.log(\"Gen1 records found:\", gen1Customers.length);\n      if (gen1Customers.length === 0) {\n        console.log(\"No Gen1 customers to display\");\n        return customerNodes;\n      }\n\n      // Group by account number to avoid duplicates\n      // Since the dropdown filters to one account, this will typically be one customer\n      const uniqueCustomers = {};\n      gen1Customers.forEach(customer => {\n        if (!uniqueCustomers[customer.account_no]) {\n          uniqueCustomers[customer.account_no] = customer;\n        }\n      });\n      console.log(\"Unique Gen1 customers:\", Object.keys(uniqueCustomers).length);\n\n      // Create nodes for each unique Gen1 customer\n      let yOffset = 250; // Start 150px lower (was 100, now 250)\n      Object.values(uniqueCustomers).forEach((customer, index) => {\n        const nodeId = `gen1-customer-${customer.account_no}`;\n\n        // Log what we're creating\n        console.log(`Creating node for: ${customer.customer} (${customer.account_no})`);\n        customerNodes.push({\n          id: nodeId,\n          type: \"custom\",\n          data: {\n            label: `${customer.customer}\\nAccount: ${customer.account_no}`\n          },\n          position: {\n            x: 1000,\n            // Move 100px to the right (was 900, now 1000)\n            y: yOffset + index * 120\n          },\n          style: {\n            width: 250,\n            height: 80,\n            backgroundColor: \"#e0f2fe\"\n          }\n        });\n      });\n      console.log(\"Customer nodes created:\", customerNodes.length);\n      return customerNodes;\n    }\n\n    /* HELPER: Generate edges for Gen1 Carriage to IVP Carriage (backbone trunks) */\n    function generateIVPCarriageEdges() {\n      const carriageEdges = [];\n\n      // Get customer data from appsmith model or use empty array\n      const customerData = typeof appsmith !== \"undefined\" && appsmith.model?.customerData ? appsmith.model.customerData : [];\n\n      // Backbone trunk names (show between DataCentres and IVP Cloud)\n      const backboneTrunks = [\"AU2 - SYD2 Gen1\", \"AU2- SYD1 GEN1\", \"AU1- SYD1 GEN1\", \"AU1- SYD2 GEN1\"];\n\n      // Collect backbone trunks and regular carriers from customer data\n      // Also track which regions have carriers\n      const foundBackboneTrunks = new Set();\n      const foundCarriers = new Set();\n      const regionsWithCarriers = new Set();\n      customerData.forEach(customer => {\n        // Only process if customer has both ivp_svccarriages AND Region Name\n        if (customer.ivp_svccarriages && customer[\"Region Name\"]) {\n          try {\n            // Parse JSON array\n            const carriages = JSON.parse(customer.ivp_svccarriages);\n            if (Array.isArray(carriages) && carriages.length > 0) {\n              // Parse Region Name to get individual regions\n              const regionNames = customer[\"Region Name\"].split(\",\").map(r => r.trim()).filter(r => r);\n\n              // Add regions to set\n              regionNames.forEach(region => regionsWithCarriers.add(region));\n              carriages.forEach(carriage => {\n                const name = carriage.name;\n                if (name) {\n                  if (backboneTrunks.includes(name)) {\n                    foundBackboneTrunks.add(name);\n                  } else {\n                    foundCarriers.add(name);\n                  }\n                }\n              });\n            }\n          } catch (e) {\n            console.error(\"Error parsing ivp_svccarriages:\", e);\n          }\n        }\n      });\n      console.log(\"IVP Backbone Trunks found:\", Array.from(foundBackboneTrunks));\n      console.log(\"IVP Carriers found:\", Array.from(foundCarriers));\n      console.log(\"Regions with carriers:\", Array.from(regionsWithCarriers));\n\n      // Create edges from DataCentres group to IVP Cloud group for backbone trunks\n      if (foundBackboneTrunks.size > 0) {\n        const trunksLabel = Array.from(foundBackboneTrunks).join(\", \");\n        console.log(`Creating DataCentres->IVP Cloud edge with trunks: ${trunksLabel}`);\n        carriageEdges.push({\n          id: `reactflow__edge-group-18bottom-source-group-9top`,\n          source: \"group-9\",\n          // IVP Cloud group\n          target: \"group-18\",\n          // DataCentres group\n          sourceHandle: \"bottom-source\",\n          targetHandle: \"top\",\n          style: {\n            stroke: \"#ef4444\",\n            strokeWidth: 4,\n            strokeDasharray: \"5,5\"\n          },\n          label: trunksLabel\n        });\n      }\n\n      // Create edges from IVP Carriage (node 2) to AU nodes for regular carriers\n      // Only create edges to regions that actually have carriers\n      if (foundCarriers.size > 0 && regionsWithCarriers.size > 0) {\n        const carriersLabel = Array.from(foundCarriers).join(\", \");\n        console.log(`Creating IVP Carriage->AU edges with carriers: ${carriersLabel}`);\n\n        // Map region names to AU node IDs\n        const regionToNodeId = {\n          AU1: \"13\",\n          AU2: \"14\"\n        };\n\n        // Create edges only to regions that have carriers\n        regionsWithCarriers.forEach(region => {\n          const auNodeId = regionToNodeId[region];\n          if (auNodeId) {\n            console.log(`  Creating edge to ${region} (${auNodeId})`);\n            carriageEdges.push({\n              id: `reactflow__edge-2right-source-${auNodeId}left-carriers`,\n              source: \"2\",\n              // IVP Carriage node\n              target: auNodeId,\n              sourceHandle: \"right-source\",\n              targetHandle: \"left\",\n              type: \"carrierConnection\",\n              style: {\n                strokeWidth: 1.5,\n                stroke: \"#10b981\"\n              },\n              data: {\n                label: carriersLabel,\n                maxWidth: 200\n              }\n            });\n          }\n        });\n      }\n      console.log(\"IVP Carriage edges created:\", carriageEdges.length);\n      return carriageEdges;\n    }\n\n    /* HELPER: Generate edges for IVP Cloud to IVP Customers */\n    function generateIVPCustomerEdges() {\n      const customerEdges = [];\n\n      // Get customer data from appsmith model or use empty array\n      const customerData = typeof appsmith !== \"undefined\" && appsmith.model?.customerData ? appsmith.model.customerData : [];\n\n      // Filter for IVP customers and deduplicate by account_no\n      const ivpCustomersAll = customerData.filter(c => c[\"Region Name\"] && c.account_no);\n      const seenAccounts = new Set();\n      const ivpCustomers = ivpCustomersAll.filter(c => {\n        if (seenAccounts.has(c.account_no)) {\n          return false;\n        }\n        seenAccounts.add(c.account_no);\n        return true;\n      });\n\n      // Map region names to AU node IDs\n      const regionToNodeId = {\n        AU1: \"13\",\n        AU2: \"14\"\n      };\n      console.log(\"=== Generating IVP Customer Edges ===\");\n\n      // Get IVP services lookup data from model\n      const ivpServicesLookup = typeof appsmith !== \"undefined\" && appsmith.model?.ivpServices ? appsmith.model.ivpServices : [];\n      console.log(`IVP Services lookup data available: ${ivpServicesLookup.length} records`);\n\n      // Process each customer and create edges for each service from ivpServices\n      ivpCustomers.forEach(customer => {\n        const externalId = customer.ivp_externalid;\n        console.log(`Processing IVP customer edge: ${customer.customer}`);\n        console.log(`  External ID: ${externalId}`);\n        if (!externalId) {\n          console.warn(`  No external ID found for customer ${customer.customer}`);\n          return;\n        }\n\n        // Find all services for this customer by externalid\n        const customerServices = ivpServicesLookup.filter(svc => svc.externalid === externalId);\n\n        // Sort services by Region Name (AU1 first, then AU2) to match node generation\n        customerServices.sort((a, b) => {\n          const regionA = a[\"Region Name\"] || \"\";\n          const regionB = b[\"Region Name\"] || \"\";\n          if (regionA === regionB) return 0;\n          if (regionA === \"AU1\") return -1;\n          if (regionB === \"AU1\") return 1;\n          return regionA.localeCompare(regionB);\n        });\n        console.log(`  Found ${customerServices.length} services in ivpServices lookup`);\n\n        // Create an edge for each service\n        customerServices.forEach((service, index) => {\n          const serviceName = service[\"Service name\"] || \"N/A\";\n          const regionName = service[\"Region Name\"];\n          const outboundUri = service[\"Outbound server/uri\"] || \"N/A\";\n          const customerNodeId = `ivp-customer-${customer.account_no}-${index}`;\n          const auNodeId = regionToNodeId[regionName];\n          if (!auNodeId) {\n            console.warn(`  No AU node found for region \"${regionName}\"`);\n            return;\n          }\n          const auName = auNodeId === \"13\" ? \"AU1\" : \"AU2\";\n          console.log(`  Creating edge: ${auName} (${auNodeId}) -> ${serviceName} (${customerNodeId}) | URI: ${outboundUri}`);\n          customerEdges.push({\n            id: `reactflow__edge-${auNodeId}right-source-${customerNodeId}left-${index}`,\n            source: auNodeId,\n            target: customerNodeId,\n            sourceHandle: \"right-source\",\n            targetHandle: \"left\",\n            type: \"carrierConnection\",\n            style: {\n              strokeWidth: 1.5,\n              stroke: \"#f97316\"\n            },\n            data: {\n              label: outboundUri,\n              maxWidth: 300\n            }\n          });\n        });\n      });\n      console.log(\"IVP Customer edges created:\", customerEdges.length);\n      return customerEdges;\n    }\n\n    /* HELPER: Generate edges for Gen1 Carriage to Data Centers */\n    function generateGen1CarriageEdges() {\n      const carriageEdges = [];\n\n      // Get customer data from appsmith model or use empty array\n      const customerData = typeof appsmith !== \"undefined\" && appsmith.model?.customerData ? appsmith.model.customerData : [];\n\n      // Map data_source to node IDs\n      const dataSourceToNodeId = {\n        SYD1A: \"19\",\n        SYD2A: \"21\",\n        SEMA: \"20\"\n      };\n\n      // Collect carrier connections by data source\n      const carriersByDataSource = {};\n      customerData.forEach(customer => {\n        if (customer.data_source && customer.carrier_connections) {\n          const dataSource = customer.data_source;\n          if (!carriersByDataSource[dataSource]) {\n            carriersByDataSource[dataSource] = new Set();\n          }\n          // Split carrier connections and add to set\n          const carriers = customer.carrier_connections.split(\",\").map(c => c.trim());\n          carriers.forEach(carrier => {\n            if (carrier) carriersByDataSource[dataSource].add(carrier);\n          });\n        }\n      });\n\n      // Create edges from Gen1 Carriage to data centers\n      Object.keys(carriersByDataSource).forEach(dataSource => {\n        const dataNodeId = dataSourceToNodeId[dataSource];\n        if (dataNodeId) {\n          const carriers = Array.from(carriersByDataSource[dataSource]).join(\", \");\n          carriageEdges.push({\n            id: `reactflow__edge-1right-source-${dataNodeId}left`,\n            source: \"1\",\n            // Gen1 Carriage node\n            target: dataNodeId,\n            sourceHandle: \"right-source\",\n            targetHandle: \"left\",\n            type: \"carrierConnection\",\n            style: {\n              strokeWidth: 1.5,\n              stroke: \"#10b981\"\n            },\n            data: {\n              label: carriers,\n              maxWidth: 200\n            }\n          });\n        }\n      });\n      console.log(\"Gen1 Carriage edges created:\", carriageEdges.length);\n      return carriageEdges;\n    }\n\n    /* HELPER: Generate edges for Gen1 Customers to Data Centers */\n    function generateGen1CustomerEdges() {\n      const customerEdges = [];\n\n      // Get customer data from appsmith model or use empty array\n      const customerData = typeof appsmith !== \"undefined\" && appsmith.model?.customerData ? appsmith.model.customerData : [];\n\n      // Filter for Gen1 customers (those with data_source field)\n      const gen1Customers = customerData.filter(c => c.data_source && c.account_no);\n\n      // Map data_source values to node IDs\n      const dataSourceToNodeId = {\n        SYD1A: \"19\",\n        // SYD1 node\n        SYD2A: \"21\",\n        // SYD2 node\n        SEMA: \"20\" // SEMA node\n      };\n\n      // Group by account number and data source to collect connection details\n      const customerConnections = {};\n      gen1Customers.forEach(customer => {\n        const accountNo = customer.account_no;\n        const dataSource = customer.data_source;\n        if (!dataSource || !dataSourceToNodeId[dataSource]) return;\n        const connectionKey = `${accountNo}-${dataSource}`;\n        if (!customerConnections[connectionKey]) {\n          customerConnections[connectionKey] = {\n            accountNo: accountNo,\n            dataSource: dataSource,\n            sourceRealm: customer.source_realm || \"N/A\",\n            sessionAgents: customer.customer_realm_session_agents || \"N/A\",\n            genesysDomains: customer.genesys_purecloud_domains || \"\" // Blank instead of N/A\n          };\n        }\n      });\n\n      // Create edges from data centers to customer nodes\n      Object.values(customerConnections).forEach(connection => {\n        const customerNodeId = `gen1-customer-${connection.accountNo}`;\n        const dataNodeId = dataSourceToNodeId[connection.dataSource];\n        if (dataNodeId) {\n          // Check if all data is N/A or empty - skip edge if so\n          const hasValidData = connection.sourceRealm !== \"N/A\" || connection.sessionAgents !== \"N/A\" || connection.genesysDomains && connection.genesysDomains !== \"\";\n          if (!hasValidData) {\n            console.log(`Skipping edge for ${connection.accountNo} - ${connection.dataSource}: all data is N/A or empty`);\n            return; // Skip this edge\n          }\n\n          // Build label lines\n          const labelLines = {\n            line1: `source_realm: ${connection.sourceRealm}`,\n            line2: `Session Agents: ${connection.sessionAgents}`,\n            line3: \"\" // Will be set below if there's a Genesys domain\n          };\n\n          // Add Genesys domain on separate line if it exists\n          if (connection.genesysDomains && connection.genesysDomains.trim() !== \"\") {\n            labelLines.line3 = connection.genesysDomains;\n          }\n\n          // Create edge with custom data for multi-line label\n          customerEdges.push({\n            id: `reactflow__edge-${dataNodeId}right-source-${customerNodeId}left`,\n            source: dataNodeId,\n            target: customerNodeId,\n            sourceHandle: \"right-source\",\n            targetHandle: \"left\",\n            type: \"custom\",\n            style: {\n              strokeWidth: 1.5,\n              stroke: \"#f97316\"\n            },\n            data: {\n              label: labelLines\n            }\n          });\n        }\n      });\n      console.log(\"Customer edges created:\", customerEdges.length);\n      return customerEdges;\n    }\n\n    /* DATA: Initial nodes from dataTopoV1 export */\n    const baseNodes = [{\n      id: \"1\",\n      type: \"custom\",\n      data: {\n        label: \"Gen1 Carriage\"\n      },\n      position: {\n        x: -92.23607459514959,\n        y: 254.45662088626688\n      },\n      style: {\n        width: 150,\n        height: 60,\n        backgroundColor: \"#ffffff\"\n      }\n    }, {\n      id: \"2\",\n      type: \"custom\",\n      data: {\n        label: \"IVP Carriage\"\n      },\n      position: {\n        x: -106.585126130654658,\n        y: -163.33815637366678\n      },\n      style: {\n        width: 150,\n        height: 60,\n        backgroundColor: \"#ffffff\"\n      }\n    }, {\n      id: \"group-9\",\n      type: \"customGroup\",\n      data: {\n        label: \"IVP Cloud\"\n      },\n      position: {\n        x: 290.0499501427992,\n        y: -259.72884777726097\n      },\n      style: {\n        width: 255,\n        height: 239\n      }\n    }, {\n      id: \"13\",\n      type: \"custom\",\n      data: {\n        label: \"AU1\"\n      },\n      position: {\n        x: 15.433429384550266,\n        y: 52.558069192486755\n      },\n      parentNode: \"group-9\",\n      extent: \"parent\",\n      style: {\n        width: 217,\n        height: 62,\n        backgroundColor: \"#ffffff\"\n      }\n    }, {\n      id: \"14\",\n      type: \"custom\",\n      data: {\n        label: \"AU2\"\n      },\n      position: {\n        x: 14.291786730687818,\n        y: 147.31440946306867\n      },\n      parentNode: \"group-9\",\n      extent: \"parent\",\n      style: {\n        width: 220,\n        height: 60,\n        backgroundColor: \"#ffffff\"\n      }\n    }, {\n      id: \"group-18\",\n      type: \"customGroup\",\n      data: {\n        label: \"DataCentres\"\n      },\n      position: {\n        x: 292.71345699905817,\n        y: 103.65544196480488\n      },\n      style: {\n        width: 247,\n        height: 346\n      }\n    }, {\n      id: \"19\",\n      type: \"custom\",\n      data: {\n        label: \"SYD1\"\n      },\n      position: {\n        x: 24.16259636112767,\n        y: 48.32519272225525\n      },\n      parentNode: \"group-18\",\n      extent: \"parent\",\n      style: {\n        width: 204,\n        height: 50,\n        backgroundColor: \"#ffffff\"\n      }\n    }, {\n      id: \"20\",\n      type: \"custom\",\n      data: {\n        label: \"SEMA\"\n      },\n      position: {\n        x: 76.24149643709859,\n        y: 159.51681709290574\n      },\n      parentNode: \"group-18\",\n      extent: \"parent\",\n      style: {\n        width: 100,\n        height: 50,\n        backgroundColor: \"#ffffff\"\n      }\n    }, {\n      id: \"21\",\n      type: \"custom\",\n      data: {\n        label: \"SYD2\"\n      },\n      position: {\n        x: 24.6304399893541,\n        y: 271.2658757959249\n      },\n      parentNode: \"group-18\",\n      extent: \"parent\",\n      style: {\n        width: 202,\n        height: 50,\n        backgroundColor: \"#ffffff\"\n      }\n    }];\n\n    // Enhance base nodes with dynamic data\n    let enhancedNodes = enhanceDataCentreNodes(baseNodes);\n    enhancedNodes = updateLocalPolicyNodes(enhancedNodes);\n\n    // Combine enhanced base nodes with generated customer nodes\n    const ivpCustomerNodes = generateIVPCustomerNodes();\n    const gen1CustomerNodes = generateGen1CustomerNodes();\n\n    // Check if customer has any IVP or Gen1 services\n    const hasIVPServices = ivpCustomerNodes.length > 0;\n    const hasGen1Services = gen1CustomerNodes.length > 0;\n    console.log(`Customer has IVP services: ${hasIVPServices}`);\n    console.log(`Customer has Gen1 services: ${hasGen1Services}`);\n\n    // Filter base nodes based on service availability\n    const filteredBaseNodes = enhancedNodes.filter(node => {\n      // IVP related nodes: 2 (IVP Carriage), group-9 (IVP Cloud), 13 (AU1), 14 (AU2)\n      const isIVPNode = [\"2\", \"group-9\", \"13\", \"14\"].includes(node.id);\n      if (isIVPNode && !hasIVPServices) {\n        console.log(`Filtering out IVP node: ${node.id} (${node.data?.label})`);\n        return false;\n      }\n\n      // Gen1 related nodes: 1 (Gen1 Carriage), group-18 (DataCentres), 19 (SYD1), 20 (SEMA), 21 (SYD2)\n      const isGen1Node = [\"1\", \"group-18\", \"19\", \"20\", \"21\"].includes(node.id);\n      if (isGen1Node && !hasGen1Services) {\n        console.log(`Filtering out Gen1 node: ${node.id} (${node.data?.label})`);\n        return false;\n      }\n      return true;\n    });\n    const initialNodes = [...filteredBaseNodes, ...ivpCustomerNodes, ...gen1CustomerNodes];\n    console.log(\"Total nodes:\", initialNodes.length, \"(Base:\", baseNodes.length, \"+ IVP Customers:\", ivpCustomerNodes.length, \"+ Gen1 Customers:\", gen1CustomerNodes.length, \")\");\n\n    /* DATA: Initial edges from dataTopoV1 export */\n    const baseEdges = [{\n      id: \"reactflow__edge-19left-source-20left\",\n      source: \"19\",\n      target: \"20\",\n      sourceHandle: \"left-source\",\n      targetHandle: \"left\",\n      style: {\n        stroke: \"#ef4444\",\n        strokeDasharray: \"5,5\"\n      },\n      label: \"Dirty\"\n    }, {\n      id: \"reactflow__edge-21left-source-20left\",\n      source: \"21\",\n      target: \"20\",\n      sourceHandle: \"left-source\",\n      targetHandle: \"left\",\n      style: {\n        stroke: \"#ef4444\",\n        strokeDasharray: \"5,5\"\n      },\n      label: \"Dirty\"\n    }, {\n      id: \"reactflow__edge-20top-source-19bottom\",\n      source: \"20\",\n      target: \"19\",\n      sourceHandle: \"top-source\",\n      targetHandle: \"bottom\",\n      style: {\n        stroke: \"#10b981\",\n        strokeDasharray: \"5,5\"\n      },\n      label: \"Clean\"\n    }, {\n      id: \"reactflow__edge-20bottom-source-21top\",\n      source: \"20\",\n      target: \"21\",\n      sourceHandle: \"bottom-source\",\n      targetHandle: \"top\",\n      style: {\n        stroke: \"#10b981\",\n        strokeDasharray: \"5,5\"\n      },\n      label: \"Clean\"\n    }];\n\n    // Check if customer uses SEMA payments to filter edges\n    const customerData = typeof appsmith !== \"undefined\" && appsmith.model?.customerData ? appsmith.model.customerData : [];\n    const usesSemaPayments = customerData.some(customer => customer.uses_sema_payments === true || customer.uses_sema_payments === \"true\");\n\n    // Filter base edges to remove SEMA connections if not using SEMA payments\n    const filteredBaseEdges = usesSemaPayments ? baseEdges : baseEdges.filter(edge => {\n      // Remove edges that involve SEMA node (ID '20')\n      const isSemaEdge = edge.source === \"20\" || edge.target === \"20\";\n      return !isSemaEdge;\n    });\n    console.log(\"Filtered SEMA edges:\", !usesSemaPayments, \"- Removed\", baseEdges.length - filteredBaseEdges.length, \"edges\");\n\n    // Generate and combine all dynamic edges\n    const ivpCarriageEdges = generateIVPCarriageEdges();\n    const ivpCustomerEdges = generateIVPCustomerEdges();\n    const gen1CarriageEdges = generateGen1CarriageEdges();\n    const gen1CustomerEdges = generateGen1CustomerEdges();\n    const initialEdges = [...filteredBaseEdges, ...ivpCarriageEdges, ...ivpCustomerEdges, ...gen1CarriageEdges, ...gen1CustomerEdges];\n    console.log(\"Total edges:\", initialEdges.length, \"(Base:\", filteredBaseEdges.length, \"+ IVP Carriage:\", ivpCarriageEdges.length, \"+ IVP Customer:\", ivpCustomerEdges.length, \"+ Gen1 Carriage:\", gen1CarriageEdges.length, \"+ Gen1 Customer:\", gen1CustomerEdges.length, \")\");\n\n    /* ====================================================================\n     * REACT FLOW COMPONENT\n     * ====================================================================\n     */\n\n    /* COMPONENT 5: Main Network Topology Component */\n    const NetworkTopology = () => {\n      // State for nodes and edges\n      const [nodes, setNodes] = React.useState(initialNodes);\n      const [edges, setEdges] = React.useState(initialEdges);\n\n      // Node types registry - must be memoized to prevent re-creation on each render\n      const nodeTypes = React.useMemo(() => ({\n        custom: CustomNode,\n        customGroup: CustomGroupNode,\n        customText: CustomTextNode\n      }), []);\n\n      // Edge types registry - must be memoized to prevent re-creation on each render\n      const edgeTypes = React.useMemo(() => ({\n        custom: CustomEdge,\n        carrierConnection: CarrierConnectionEdge\n      }), []);\n      console.log(\"Rendering ReactFlow with\", nodes.length, \"nodes and\", edges.length, \"edges\");\n\n      // Expose update function globally so appsmith.onModelChange can call it\n      React.useEffect(() => {\n        window.updateTopology = () => {\n          console.log(\"Updating topology with new customer data...\");\n\n          // Check if customer uses SEMA payments\n          const updatedCustomerData = typeof appsmith !== \"undefined\" && appsmith.model?.customerData ? appsmith.model.customerData : [];\n          const updatedUsesSemaPayments = updatedCustomerData.some(customer => customer.uses_sema_payments === true || customer.uses_sema_payments === \"true\");\n\n          // Regenerate and enhance base nodes\n          let newEnhancedNodes = enhanceDataCentreNodes(baseNodes);\n          newEnhancedNodes = updateLocalPolicyNodes(newEnhancedNodes);\n\n          // Regenerate customer nodes\n          const newIVPCustomerNodes = generateIVPCustomerNodes();\n          const newGen1CustomerNodes = generateGen1CustomerNodes();\n\n          // Check if customer has any IVP or Gen1 services\n          const newHasIVPServices = newIVPCustomerNodes.length > 0;\n          const newHasGen1Services = newGen1CustomerNodes.length > 0;\n          console.log(`Customer has IVP services: ${newHasIVPServices}`);\n          console.log(`Customer has Gen1 services: ${newHasGen1Services}`);\n\n          // Filter base nodes based on service availability\n          const newFilteredBaseNodes = newEnhancedNodes.filter(node => {\n            // IVP related nodes: 2 (IVP Carriage), group-9 (IVP Cloud), 13 (AU1), 14 (AU2)\n            const isIVPNode = [\"2\", \"group-9\", \"13\", \"14\"].includes(node.id);\n            if (isIVPNode && !newHasIVPServices) {\n              return false;\n            }\n\n            // Gen1 related nodes: 1 (Gen1 Carriage), group-18 (DataCentres), 19 (SYD1), 20 (SEMA), 21 (SYD2)\n            const isGen1Node = [\"1\", \"group-18\", \"19\", \"20\", \"21\"].includes(node.id);\n            if (isGen1Node && !newHasGen1Services) {\n              return false;\n            }\n            return true;\n          });\n          const newNodes = [...newFilteredBaseNodes, ...newIVPCustomerNodes, ...newGen1CustomerNodes];\n\n          // Filter base edges to remove SEMA connections if not using SEMA payments\n          const newFilteredBaseEdges = updatedUsesSemaPayments ? baseEdges : baseEdges.filter(edge => {\n            const isSemaEdge = edge.source === \"20\" || edge.target === \"20\";\n            return !isSemaEdge;\n          });\n\n          // Regenerate edges\n          const newIVPCarriageEdges = generateIVPCarriageEdges();\n          const newIVPCustomerEdges = generateIVPCustomerEdges();\n          const newGen1CarriageEdges = generateGen1CarriageEdges();\n          const newGen1CustomerEdges = generateGen1CustomerEdges();\n          const newEdges = [...newFilteredBaseEdges, ...newIVPCarriageEdges, ...newIVPCustomerEdges, ...newGen1CarriageEdges, ...newGen1CustomerEdges];\n          console.log(\"New topology generated:\", newNodes.length, \"nodes,\", newEdges.length, \"edges\");\n          console.log(\"SEMA edges filtered:\", !updatedUsesSemaPayments);\n\n          // Update state\n          setNodes(newNodes);\n          setEdges(newEdges);\n        };\n      }, []);\n      console.log(\"Rendering ReactFlow with nodes:\", nodes.length, \"edges:\", edges.length);\n      console.log(\"First edge:\", edges[0]);\n      return React.createElement(\"div\", {\n        style: {\n          width: \"100%\",\n          height: \"100%\"\n        }\n      }, React.createElement(ReactFlow, {\n        nodes,\n        edges,\n        nodeTypes,\n        edgeTypes,\n        fitView: true,\n        fitViewOptions: {\n          padding: 0.2,\n          includeHiddenNodes: false\n        },\n        minZoom: 0.1,\n        maxZoom: 2,\n        defaultViewport: {\n          x: 0,\n          y: 0,\n          zoom: 0.8\n        },\n        attributionPosition: \"bottom-left\",\n        onInit: instance => {\n          console.log(\"ReactFlow initialized\");\n          console.log(\"Edges in store:\", instance.getEdges().length);\n        }\n      }, React.createElement(Controls, {\n        showZoom: true,\n        showFitView: true,\n        showInteractive: true\n      }), React.createElement(MiniMap, {\n        nodeColor: node => {\n          if (node.type === \"customGroup\") return \"rgba(66, 153, 225, 0.3)\";\n          if (node.type === \"customText\") return \"#fffef0\";\n          if (node.style?.backgroundColor) return node.style.backgroundColor;\n          return \"#ffffff\";\n        },\n        maskColor: \"rgba(0, 0, 0, 0.1)\",\n        zoomable: true,\n        pannable: true\n      }), React.createElement(Background, {\n        variant: \"dots\",\n        gap: 16,\n        size: 1,\n        color: \"#e5e7eb\"\n      })));\n    };\n\n    /* ====================================================================\n     * RENDER TO DOM\n     * ====================================================================\n     */\n\n    console.log(\"âœ“ Custom node components created\");\n    console.log(\"âœ“ Network topology data loaded\");\n\n    // Render the React Flow component\n    const container = document.getElementById(\"root\");\n    if (!container) {\n      throw new Error(\"Root container not found\");\n    }\n    const root = ReactDOMClient.createRoot(container);\n\n    // Check if ReactFlowProvider exists\n    if (ReactFlowProvider) {\n      console.log(\"Using ReactFlowProvider to wrap app\");\n      const App = () => React.createElement(ReactFlowProvider, null, React.createElement(NetworkTopology));\n      root.render(React.createElement(App));\n    } else {\n      console.log(\"No ReactFlowProvider found, rendering directly\");\n      root.render(React.createElement(NetworkTopology));\n    }\n    console.log(\"âœ“ DataTopoV1 Network Topology Rendered Successfully\");\n    console.log(\"ðŸ“Š Nodes:\", initialNodes.length);\n    console.log(\"ðŸ”— Edges:\", initialEdges.length);\n  } catch (error) {\n    console.error(\"âŒ Error initializing network topology:\", error);\n    const container = document.getElementById(\"root\");\n    if (container) {\n      container.innerHTML = '<div class=\"topology-error\">' + \"<h3>Error Loading Network Topology</h3>\" + \"<p><strong>Error:</strong> \" + error.message + \"</p>\" + \"<pre>\" + error.stack + \"</pre>\" + \"</div>\";\n    }\n  }\n}\n\n/* ========================================================================\n * APPSMITH MODEL UPDATE HANDLER\n * ========================================================================\n */\n\n// Listen for model updates from Appsmith\nappsmith.onModelChange(() => {\n  console.log(\"Model data updated:\", appsmith.model);\n\n  // Trigger topology update when customer data changes\n  if (typeof window.updateTopology === \"function\") {\n    window.updateTopology();\n  }\n});\n\n/* ========================================================================\n * UTILITY FUNCTIONS (Optional)\n * ========================================================================\n */\n\n// Helper function to format node data\nfunction formatNodeLabel(data) {\n  if (!data) return \"N/A\";\n  if (typeof data === \"string\") return data;\n  return JSON.stringify(data);\n}\n\n// Helper function to validate edge connections\nfunction isValidConnection(connection) {\n  return connection.source && connection.target;\n}\nconsole.log(\"âœ“ DataTopoV1 widget script loaded\");"
  },
  "theme": "{{appsmith.theme}}",
  "topRow": 7,
  "type": "CUSTOM_WIDGET",
  "uncompiledSrcDoc": {
    "css": "/* ============================================================================\n   DATA TOPOLOGY V1 - CSS STYLES FOR APPSMITH WIDGET\n   ============================================================================\n\n   This CSS file contains all styling for the dataTopoV1 network topology\n   React Flow diagram, including custom node types and layout.\n\n   Copy this content into the \"CSS\" tab of your Custom Widget Builder.\n\n   ============================================================================ */\n\n/* ============================================================================\n   SECTION 1: Container Reset & Layout\n   ============================================================================ */\n\n/* Function 1.1: Reset default styles and ensure full viewport */\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\n/* Function 1.2: Root container takes full widget space */\n#root {\n  width: 100%;\n  height: 100%;\n  min-height: 600px;\n  position: relative;\n  overflow: hidden;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n/* ============================================================================\n   SECTION 2: React Flow Specific Overrides\n   ============================================================================ */\n\n/* Function 2.1: Ensure React Flow container fills space */\n.react-flow {\n  width: 100% !important;\n  height: 100% !important;\n}\n\n/* Function 2.2: Style minimap for better visibility */\n.react-flow__minimap {\n  background-color: #f9fafb;\n  border: 1px solid #e5e7eb;\n  border-radius: 4px;\n}\n\n/* Function 2.3: Style controls panel */\n.react-flow__controls {\n  background-color: white;\n  border: 1px solid #e5e7eb;\n  border-radius: 6px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n/* Function 2.4: Style control buttons */\n.react-flow__controls-button {\n  border-bottom: 1px solid #e5e7eb;\n  background-color: white;\n  transition: background-color 0.2s;\n}\n\n.react-flow__controls-button:hover {\n  background-color: #f3f4f6;\n}\n\n.react-flow__controls-button:last-child {\n  border-bottom: none;\n}\n\n/* ============================================================================\n   SECTION 3: Custom Node Types - Standard Node\n   ============================================================================ */\n\n/* Function 3.1: Custom node base styling */\n.custom-node {\n  padding: 10px 20px;\n  border-radius: 5px;\n  border: 2px solid #1a192b;\n  min-width: 100px;\n  min-height: 50px;\n  width: 100%;\n  height: 100%;\n  text-align: center;\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: #ffffff;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  transition: box-shadow 0.2s;\n}\n\n.custom-node:hover {\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);\n}\n\n.custom-node-content {\n  font-size: 14px;\n  color: #222;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  word-wrap: break-word;\n  padding: 5px;\n}\n\n/* Function 3.2: Node selection highlighting */\n.react-flow__node.selected .custom-node {\n  box-shadow: 0 0 0 3px #3b82f6;\n}\n\n/* ============================================================================\n   SECTION 4: Custom Node Types - Group Node\n   ============================================================================ */\n\n/* Function 4.1: Custom group node for containers */\n.custom-group-node {\n  width: 100%;\n  height: 100%;\n  background: rgba(240, 240, 255, 0.25);\n  border: 2px dashed #4299e1;\n  border-radius: 8px;\n  position: relative;\n  padding: 10px;\n  pointer-events: none;\n}\n\n.custom-group-node-label {\n  position: absolute;\n  top: 5px;\n  left: 10px;\n  font-size: 14px;\n  font-weight: 600;\n  color: #2d3748;\n  background: rgba(255, 255, 255, 0.9);\n  padding: 4px 8px;\n  border-radius: 4px;\n  border: 1px solid #cbd5e0;\n  z-index: 10;\n  pointer-events: all;\n}\n\n/* ============================================================================\n   SECTION 5: Custom Node Types - Text Node\n   ============================================================================ */\n\n/* Function 5.1: Custom text node for annotations */\n.custom-text-node {\n  padding: 12px;\n  border-radius: 4px;\n  border: 1px solid #cbd5e0;\n  min-width: 150px;\n  min-height: 100px;\n  width: 100%;\n  height: 100%;\n  position: relative;\n  display: flex;\n  align-items: flex-start;\n  justify-content: flex-start;\n  background: #fffef0;\n}\n\n.custom-text-node-content {\n  font-size: 13px;\n  color: #222;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  overflow-wrap: break-word;\n  padding: 5px;\n  width: 100%;\n  height: 100%;\n  overflow-y: auto;\n  line-height: 1.5;\n  text-align: left;\n}\n\n/* ============================================================================\n   SECTION 6: Handle (Connection Point) Styling\n   ============================================================================ */\n\n/* Function 6.1: Base handle styling for all nodes */\n.react-flow__handle {\n  width: 10px;\n  height: 10px;\n  border-radius: 50%;\n  background: #555;\n  border: 2px solid white;\n  transition: all 0.2s;\n}\n\n.custom-node .react-flow__handle,\n.custom-group-node .react-flow__handle,\n.custom-text-node .react-flow__handle {\n  width: 10px;\n  height: 10px;\n  border-radius: 50%;\n  border: 2px solid white;\n}\n\n.custom-node .react-flow__handle {\n  background: #555;\n}\n\n.custom-group-node .react-flow__handle {\n  background: #4299e1;\n  pointer-events: all;\n}\n\n.custom-text-node .react-flow__handle {\n  background: #555;\n}\n\n/* Function 6.2: Handle position adjustments */\n.react-flow__handle-top {\n  top: -6px;\n}\n\n.react-flow__handle-bottom {\n  bottom: -6px;\n}\n\n.react-flow__handle-left {\n  left: -6px;\n}\n\n.react-flow__handle-right {\n  right: -6px;\n}\n\n/* Function 6.3: Handle hover state */\n.react-flow__handle:hover {\n  background-color: #3b82f6;\n  transform: scale(1.2);\n}\n\n/* Function 6.4: Handle connection state */\n.react-flow__handle-connecting {\n  background-color: #10b981;\n}\n\n/* Function 6.5: Valid connection target */\n.react-flow__handle-valid {\n  background-color: #10b981;\n}\n\n/* ============================================================================\n   SECTION 7: Edge (Connection) Styling\n   ============================================================================ */\n\n/* Function 7.1: Edge label styling */\n.react-flow__edge-text {\n  font-size: 11px;\n  font-weight: 600;\n  fill: #374151;\n}\n\n/* Function 7.1b: Edge label foreignObject styling for HTML labels */\n.react-flow__edge foreignObject {\n  overflow: visible;\n}\n\n.react-flow__edge foreignObject > div {\n  transform: translate(-50%, -50%);\n}\n\n/* Function 7.1c: Edge label background */\n.react-flow__edge-textbg {\n  fill: rgba(255, 255, 255, 0.9);\n  rx: 4;\n  ry: 4;\n}\n\n/* Function 7.2: Connection line preview */\n.react-flow__connection-path {\n  stroke: #6366f1;\n  stroke-width: 2;\n}\n\n/* Function 7.3: Selected edge highlighting */\n.react-flow__edge.selected .react-flow__edge-path {\n  stroke: #3b82f6;\n  stroke-width: 3;\n}\n\n/* ============================================================================\n   SECTION 8: Background & Grid\n   ============================================================================ */\n\n/* Function 8.1: Background pattern styling */\n.react-flow__background {\n  background-color: #ffffff;\n}\n\n/* Function 8.2: Grid dot styling */\n.react-flow__background-pattern {\n  fill: #e5e7eb;\n}\n\n/* ============================================================================\n   SECTION 9: Node Resizer Styling\n   ============================================================================ */\n\n/* Function 9.1: Custom node resizer */\n.custom-node-resizer-line {\n  border-color: #4299e1 !important;\n  border-width: 2px !important;\n}\n\n.custom-node-resizer-handle {\n  width: 10px !important;\n  height: 10px !important;\n  border-radius: 2px !important;\n  background-color: #4299e1 !important;\n}\n\n/* Function 9.2: Group node resizer */\n.custom-group-resizer-line {\n  border-color: #3182ce !important;\n  border-width: 2px !important;\n  border-style: solid !important;\n  pointer-events: all !important;\n}\n\n.custom-group-resizer-handle {\n  width: 12px !important;\n  height: 12px !important;\n  border-radius: 2px !important;\n  background-color: #3182ce !important;\n  pointer-events: all !important;\n}\n\n.custom-group-node .react-flow__resize-control {\n  pointer-events: all !important;\n}\n\n/* Function 9.3: Text node resizer */\n.custom-text-node-resizer-line {\n  border-color: #4299e1 !important;\n  border-width: 2px !important;\n}\n\n.custom-text-node-resizer-handle {\n  width: 10px !important;\n  height: 10px !important;\n  border-radius: 2px !important;\n  background-color: #4299e1 !important;\n}\n\n/* ============================================================================\n   SECTION 10: Loading & Error States\n   ============================================================================ */\n\n/* Function 10.1: Loading indicator */\n.topology-loading {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;\n  color: #6b7280;\n  font-size: 14px;\n}\n\n/* Function 10.2: Error message styling */\n.topology-error {\n  padding: 20px;\n  color: #ef4444;\n  font-family: monospace;\n  background-color: #fef2f2;\n  border: 1px solid #fecaca;\n  border-radius: 6px;\n  margin: 20px;\n  font-size: 13px;\n}\n\n.topology-error h3 {\n  margin-bottom: 10px;\n  color: #dc2626;\n}\n\n.topology-error pre {\n  background: #f5f5f5;\n  padding: 10px;\n  overflow: auto;\n  border-radius: 4px;\n  font-size: 11px;\n}\n\n/* ============================================================================\n   SECTION 11: Utility Classes\n   ============================================================================ */\n\n/* Function 11.1: Text utilities */\n.text-center {\n  text-align: center;\n}\n\n.text-left {\n  text-align: left;\n}\n\n.pre-line {\n  white-space: pre-line;\n}\n\n/* Function 11.2: Spacing utilities */\n.p-20 {\n  padding: 20px;\n}\n\n.m-20 {\n  margin: 20px;\n}\n",
    "html": "<!-- ============================================================================\n     DATA TOPOLOGY V1 - HTML COMPONENT FOR APPSMITH\n     ============================================================================\n\n     This is the HTML section of the Appsmith Custom Widget for the\n     dataTopoV1 network topology diagram.\n\n     Copy this content into the \"HTML\" tab of your Custom Widget Builder.\n\n     Components:\n     1. Root container for React rendering\n     2. Import map for ESM module resolution\n     3. React Flow CSS stylesheet\n\n     ============================================================================\n-->\n\n<!-- Root Container -->\n<div id=\"root\" style=\"width: 100%; height: 800px;\"></div>\n\n<!-- React Flow CSS -->\n<link\n  href=\"https://cdn.jsdelivr.net/npm/reactflow@11.11.4/dist/style.min.css\"\n  rel=\"stylesheet\"\n/>\n",
    "js": "/* ============================================================================\n * DATA TOPOLOGY V1 - APPSMITH CUSTOM WIDGET JAVASCRIPT\n * ============================================================================\n *\n * Project: Network Topology Visualization with React Flow\n * Template: dataTopoV1 (Auto-generated flow)\n * Created: November 2025\n *\n * Purpose: Interactive network topology diagram using React Flow with\n * custom node types (CustomNode, CustomGroupNode, CustomTextNode)\n *\n * Appsmith Integration:\n * - Uses appsmith.onReady() for initialization\n * - Supports dynamic data updates via appsmith.model\n * - ESM module imports for React and React Flow\n *\n * Copy this content into the \"JS\" tab of your Custom Widget Builder.\n *\n * ============================================================================\n */\n\n/* ========================================================================\n * APPSMITH INITIALIZATION\n * ========================================================================\n */\n\nappsmith.onReady(() => {\n  console.log(\"=== DataTopoV1 Network Topology Initializing ===\");\n\n  // Main initialization function\n  initializeNetworkTopology();\n});\n\n/* ========================================================================\n * MAIN INITIALIZATION FUNCTION\n * ========================================================================\n */\n\nasync function initializeNetworkTopology() {\n  try {\n    /* STEP 1: Import React Libraries - Share same instance globally */\n    if (!window.React) {\n      window.React = await import(\"https://esm.sh/react@18.3.1\");\n    }\n    if (!window.ReactDOM) {\n      window.ReactDOM = await import(\"https://esm.sh/react-dom@18.3.1\");\n    }\n\n    const React = window.React;\n    const ReactDOMClient = await import(\n      \"https://esm.sh/react-dom@18.3.1/client\"\n    );\n\n    // Import ReactFlow with pinned React version\n    const ReactFlowModule = await import(\n      \"https://esm.sh/reactflow@11.11.4?deps=react@18.3.1,react-dom@18.3.1&bundle\"\n    );\n\n    const {\n      default: ReactFlow,\n      Controls,\n      Background,\n      MiniMap,\n      Handle,\n      Position,\n      NodeResizer,\n      ReactFlowProvider,\n      getBezierPath,\n      EdgeLabelRenderer,\n      BaseEdge,\n    } = ReactFlowModule;\n\n    console.log(\"âœ“ React and React Flow modules loaded\");\n    console.log(\"ReactFlowProvider available:\", typeof ReactFlowProvider);\n\n    /* ====================================================================\n     * CUSTOM EDGE COMPONENT\n     * ====================================================================\n     */\n\n    /* COMPONENT: CarrierConnectionEdge - Edge for carrier connections with comma-based wrapping */\n    const CarrierConnectionEdge = ({\n      id,\n      sourceX,\n      sourceY,\n      targetX,\n      targetY,\n      sourcePosition,\n      targetPosition,\n      style = {},\n      data,\n    }) => {\n      const [edgePath, labelX, labelY] = getBezierPath({\n        sourceX,\n        sourceY,\n        sourcePosition,\n        targetX,\n        targetY,\n        targetPosition,\n      });\n\n      // Helper function to wrap text only at commas with max width\n      const wrapAtCommas = (text, maxWidth = 200) => {\n        if (!text) return [];\n\n        const items = text.split(\",\").map((item) => item.trim());\n        const lines = [];\n        let currentLine = \"\";\n\n        items.forEach((item, index) => {\n          const isLast = index === items.length - 1;\n          const itemWithComma = isLast ? item : item + \",\";\n\n          // Estimate character width (roughly 6-7px per char at 11px font)\n          const estimatedWidth = (currentLine + \" \" + itemWithComma).length * 7;\n\n          if (currentLine === \"\") {\n            currentLine = itemWithComma;\n          } else if (estimatedWidth <= maxWidth) {\n            currentLine += \" \" + itemWithComma;\n          } else {\n            lines.push(currentLine);\n            currentLine = itemWithComma;\n          }\n        });\n\n        if (currentLine) lines.push(currentLine);\n        return lines;\n      };\n\n      const labelLines = data?.label\n        ? wrapAtCommas(data.label, data.maxWidth || 200)\n        : [];\n\n      return React.createElement(\n        React.Fragment,\n        null,\n        React.createElement(BaseEdge, { path: edgePath, style: style }),\n        labelLines.length > 0 &&\n          React.createElement(\n            EdgeLabelRenderer,\n            null,\n            React.createElement(\n              \"div\",\n              {\n                style: {\n                  position: \"absolute\",\n                  transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n                  background: \"rgba(255, 255, 255, 0.95)\",\n                  padding: \"6px 10px\",\n                  borderRadius: \"4px\",\n                  fontSize: \"11px\",\n                  border: \"1px solid #e5e7eb\",\n                  lineHeight: \"1.5\",\n                  whiteSpace: \"nowrap\",\n                  textAlign: \"left\",\n                  boxShadow: \"0 1px 3px rgba(0,0,0,0.1)\",\n                  fontFamily:\n                    '-apple-system, BlinkMacSystemFont, \"Segoe UI\", sans-serif',\n                  pointerEvents: \"all\",\n                  maxWidth: `${data.maxWidth || 200}px`,\n                },\n                className: \"nodrag nopan\",\n              },\n              labelLines.map((line, idx) =>\n                React.createElement(\"div\", { key: idx }, line),\n              ),\n            ),\n          ),\n      );\n    };\n\n    /* COMPONENT: CustomEdge - Edge with multi-line label */\n    const CustomEdge = ({\n      id,\n      sourceX,\n      sourceY,\n      targetX,\n      targetY,\n      sourcePosition,\n      targetPosition,\n      style = {},\n      data,\n    }) => {\n      const [edgePath, labelX, labelY] = getBezierPath({\n        sourceX,\n        sourceY,\n        sourcePosition,\n        targetX,\n        targetY,\n        targetPosition,\n      });\n\n      // Helper function to wrap text at max character length\n      const wrapText = (text, maxLength = 60) => {\n        if (!text || text.length <= maxLength) return [text];\n\n        const lines = [];\n        let currentLine = \"\";\n        const words = text.split(\" \");\n\n        for (const word of words) {\n          if ((currentLine + \" \" + word).trim().length <= maxLength) {\n            currentLine = currentLine ? currentLine + \" \" + word : word;\n          } else {\n            if (currentLine) lines.push(currentLine);\n            currentLine = word;\n          }\n        }\n        if (currentLine) lines.push(currentLine);\n\n        return lines;\n      };\n\n      // Wrap each line if needed\n      const line1Parts = data?.label?.line1 ? wrapText(data.label.line1) : [];\n      const line2Parts = data?.label?.line2 ? wrapText(data.label.line2) : [];\n      const line3Parts = data?.label?.line3 ? wrapText(data.label.line3) : [];\n\n      return React.createElement(\n        React.Fragment,\n        null,\n        React.createElement(BaseEdge, { path: edgePath, style: style }),\n        data &&\n          data.label &&\n          React.createElement(\n            EdgeLabelRenderer,\n            null,\n            React.createElement(\n              \"div\",\n              {\n                style: {\n                  position: \"absolute\",\n                  transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n                  background: \"rgba(255, 255, 255, 0.95)\",\n                  padding: \"6px 10px\",\n                  borderRadius: \"4px\",\n                  fontSize: \"11px\",\n                  border: \"1px solid #e5e7eb\",\n                  lineHeight: \"1.5\",\n                  whiteSpace: \"pre-wrap\",\n                  textAlign: \"left\",\n                  boxShadow: \"0 1px 3px rgba(0,0,0,0.1)\",\n                  fontFamily:\n                    '-apple-system, BlinkMacSystemFont, \"Segoe UI\", sans-serif',\n                  pointerEvents: \"all\",\n                  maxWidth: \"300px\",\n                },\n                className: \"nodrag nopan\",\n              },\n              line1Parts.map((part, idx) =>\n                React.createElement(\"div\", { key: `line1-${idx}` }, part),\n              ),\n              line2Parts.map((part, idx) =>\n                React.createElement(\"div\", { key: `line2-${idx}` }, part),\n              ),\n              line3Parts.map((part, idx) =>\n                React.createElement(\"div\", { key: `line3-${idx}` }, part),\n              ),\n            ),\n          ),\n      );\n    };\n\n    /* ====================================================================\n     * CUSTOM NODE COMPONENTS\n     * ====================================================================\n     */\n\n    /* COMPONENT 1: CustomNode - Standard resizable node with handles */\n    const CustomNode = ({ data, isConnectable, selected }) => {\n      const labelText = String(data?.label || \"\");\n\n      // Split label by newlines and create separate divs for each line\n      const labelLines = labelText\n        .split(\"\\n\")\n        .map((line, index) => React.createElement(\"div\", { key: index }, line));\n\n      return React.createElement(\n        \"div\",\n        { className: \"custom-node\" },\n        React.createElement(NodeResizer, {\n          minWidth: 100,\n          minHeight: 50,\n          isVisible: selected,\n        }),\n        React.createElement(Handle, {\n          type: \"target\",\n          position: Position.Top,\n          id: \"top\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"target\",\n          position: Position.Left,\n          id: \"left\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"target\",\n          position: Position.Right,\n          id: \"right\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"target\",\n          position: Position.Bottom,\n          id: \"bottom\",\n          isConnectable,\n        }),\n        React.createElement(\n          \"div\",\n          { className: \"custom-node-content\" },\n          ...labelLines,\n        ),\n        React.createElement(Handle, {\n          type: \"source\",\n          position: Position.Top,\n          id: \"top-source\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"source\",\n          position: Position.Left,\n          id: \"left-source\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"source\",\n          position: Position.Right,\n          id: \"right-source\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"source\",\n          position: Position.Bottom,\n          id: \"bottom-source\",\n          isConnectable,\n        }),\n      );\n    };\n\n    /* COMPONENT 2: CustomGroupNode - Group/container node */\n    const CustomGroupNode = ({ data, isConnectable, selected }) => {\n      const labelText = String(data?.label || \"\");\n\n      return React.createElement(\n        \"div\",\n        { className: \"custom-group-node\" },\n        React.createElement(NodeResizer, {\n          minWidth: 200,\n          minHeight: 150,\n          isVisible: selected,\n        }),\n        React.createElement(Handle, {\n          type: \"target\",\n          position: Position.Top,\n          id: \"top\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"target\",\n          position: Position.Left,\n          id: \"left\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"target\",\n          position: Position.Right,\n          id: \"right\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"target\",\n          position: Position.Bottom,\n          id: \"bottom\",\n          isConnectable,\n        }),\n        React.createElement(\n          \"div\",\n          { className: \"custom-group-node-label\" },\n          labelText,\n        ),\n        React.createElement(Handle, {\n          type: \"source\",\n          position: Position.Top,\n          id: \"top-source\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"source\",\n          position: Position.Left,\n          id: \"left-source\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"source\",\n          position: Position.Right,\n          id: \"right-source\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"source\",\n          position: Position.Bottom,\n          id: \"bottom-source\",\n          isConnectable,\n        }),\n      );\n    };\n\n    /* COMPONENT 3: CustomTextNode - Text/annotation node */\n    const CustomTextNode = ({ data, isConnectable, selected }) => {\n      const labelText = String(data?.label || \"\");\n      const isHtml = data?.isHtml || false;\n\n      return React.createElement(\n        \"div\",\n        { className: \"custom-text-node\" },\n        React.createElement(NodeResizer, {\n          minWidth: 150,\n          minHeight: 100,\n          isVisible: selected,\n        }),\n        React.createElement(Handle, {\n          type: \"target\",\n          position: Position.Top,\n          id: \"top\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"target\",\n          position: Position.Left,\n          id: \"left\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"target\",\n          position: Position.Right,\n          id: \"right\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"target\",\n          position: Position.Bottom,\n          id: \"bottom\",\n          isConnectable,\n        }),\n        React.createElement(\n          \"div\",\n          {\n            className: \"custom-text-node-content\",\n            ...(isHtml\n              ? { dangerouslySetInnerHTML: { __html: labelText } }\n              : {}),\n          },\n          isHtml ? null : labelText,\n        ),\n        React.createElement(Handle, {\n          type: \"source\",\n          position: Position.Top,\n          id: \"top-source\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"source\",\n          position: Position.Left,\n          id: \"left-source\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"source\",\n          position: Position.Right,\n          id: \"right-source\",\n          isConnectable,\n        }),\n        React.createElement(Handle, {\n          type: \"source\",\n          position: Position.Bottom,\n          id: \"bottom-source\",\n          isConnectable,\n        }),\n      );\n    };\n\n    /* ====================================================================\n     * NETWORK TOPOLOGY DATA - dataTopoV1\n     * ====================================================================\n     */\n\n    /* HELPER: Convert Markdown Table to HTML */\n    function markdownTableToHtml(markdown) {\n      if (!markdown || typeof markdown !== \"string\") return \"\";\n\n      const lines = markdown\n        .trim()\n        .split(\"\\n\")\n        .filter((line) => line.trim());\n      if (lines.length === 0) return \"\";\n\n      // Column headers based on position\n      const columnHeaders = [\n        \"SBC\",\n        \"From_Range\",\n        \"To_Range\",\n        \"Status\",\n        \"Source_Realm\",\n        \"Next_Hop\",\n        \"Dest_Realm\",\n      ];\n\n      let html =\n        '<table style=\"width: 100%; border-collapse: collapse; font-size: 11px;\">';\n      let headerAdded = false;\n\n      // Process each line\n      lines.forEach((line, index) => {\n        // Skip separator line (contains dashes)\n        if (line.includes(\"---\") || line.includes(\"|-\")) return;\n\n        // Split by pipe and clean up - remove > and < characters\n        const cells = line\n          .split(\"|\")\n          .map((cell) => cell.trim().replace(/[><]/g, \"\"))\n          .filter((cell) => cell);\n\n        if (cells.length === 0) return;\n\n        // Add header on first data line\n        if (!headerAdded) {\n          html += '<thead><tr style=\"background: #f3f4f6; font-weight: 600;\">';\n\n          // Use column headers based on number of columns in data\n          const numColumns = cells.length;\n          for (let i = 0; i < numColumns && i < columnHeaders.length; i++) {\n            html += `<th style=\"border: 1px solid #d1d5db; padding: 6px 8px; text-align: left;\">${columnHeaders[i]}</th>`;\n          }\n\n          html += \"</tr></thead><tbody>\";\n          headerAdded = true;\n        }\n\n        // Add data row\n        html += \"<tr>\";\n        cells.forEach((cell) => {\n          html += `<td style=\"border: 1px solid #d1d5db; padding: 6px 8px;\">${cell}</td>`;\n        });\n        html += \"</tr>\";\n      });\n\n      html += \"</tbody></table>\";\n      return html;\n    }\n\n    /* HELPER: Update Local Policy Text Nodes */\n    function updateLocalPolicyNodes(baseNodes) {\n      // Get customer data from appsmith model or use empty array\n      const customerData =\n        typeof appsmith !== \"undefined\" && appsmith.model?.customerData\n          ? appsmith.model.customerData\n          : [];\n\n      // Get local policy summary for SYD1A\n      const syd1PolicyData = customerData.find(\n        (c) => c.data_source === \"SYD1A\" && c.local_policy_summary,\n      );\n\n      return baseNodes.map((node) => {\n        // Update Local Policy SYD1 text node (text-22)\n        if (node.id === \"text-22\" && syd1PolicyData?.local_policy_summary) {\n          const htmlTable = markdownTableToHtml(\n            syd1PolicyData.local_policy_summary,\n          );\n          const accountNo = syd1PolicyData.account_no || \"\";\n\n          return {\n            ...node,\n            data: {\n              ...node.data,\n              label: htmlTable,\n              isHtml: true, // Flag to render as HTML\n            },\n          };\n        }\n        return node;\n      });\n    }\n\n    /* HELPER: Enhance DataCentre Nodes with SIP Interface IPs */\n    function enhanceDataCentreNodes(baseNodes) {\n      // Get customer data from appsmith model or use empty array\n      const customerData =\n        typeof appsmith !== \"undefined\" && appsmith.model?.customerData\n          ? appsmith.model.customerData\n          : [];\n\n      // Map data_source to node IDs\n      const dataSourceToNodeId = {\n        SYD1A: \"19\",\n        SYD2A: \"21\",\n        SEMA: \"20\",\n      };\n\n      // Check if customer uses SEMA payments\n      const usesSemaPayments = customerData.some(\n        (customer) =>\n          customer.uses_sema_payments === true ||\n          customer.uses_sema_payments === \"true\",\n      );\n\n      console.log(\"Customer uses SEMA payments:\", usesSemaPayments);\n\n      // Collect SIP interface IPs by data source\n      const sipInterfacesByNode = {};\n      customerData.forEach((customer) => {\n        if (customer.data_source && customer.sip_interface_ips) {\n          const nodeId = dataSourceToNodeId[customer.data_source];\n          if (nodeId) {\n            if (!sipInterfacesByNode[nodeId]) {\n              sipInterfacesByNode[nodeId] = new Set();\n            }\n            // Add IPs to the set (automatically deduplicates)\n            const ips = customer.sip_interface_ips\n              .split(\",\")\n              .map((ip) => ip.trim());\n            ips.forEach((ip) => sipInterfacesByNode[nodeId].add(ip));\n          }\n        }\n      });\n\n      // Update node labels with SIP interface IPs and grey out SEMA if not used\n      return baseNodes.map((node) => {\n        let updatedNode = { ...node };\n\n        // Add SIP interfaces if available\n        if (sipInterfacesByNode[node.id]) {\n          const ips = Array.from(sipInterfacesByNode[node.id]).join(\", \");\n          const originalLabel = node.data.label;\n          updatedNode = {\n            ...updatedNode,\n            data: {\n              ...updatedNode.data,\n              label: `${originalLabel}\\nSIP Interfaces: ${ips}`,\n            },\n          };\n        }\n\n        // Grey out SEMA node if not using SEMA payments\n        if (node.id === \"20\" && !usesSemaPayments) {\n          updatedNode = {\n            ...updatedNode,\n            style: {\n              ...updatedNode.style,\n              backgroundColor: \"#d1d5db\", // Grey color\n              opacity: 0.6,\n            },\n          };\n        }\n\n        return updatedNode;\n      });\n    }\n\n    /* HELPER: Generate IVP Customer Nodes from appsmith data */\n    function generateIVPCustomerNodes() {\n      const customerNodes = [];\n\n      // Get customer data from appsmith model or use empty array\n      const customerData =\n        typeof appsmith !== \"undefined\" && appsmith.model?.customerData\n          ? appsmith.model.customerData\n          : [];\n\n      console.log(\"=== IVP Customer Data ===\");\n      console.log(\"Total customer records:\", customerData.length);\n      if (customerData.length > 0) {\n        console.log(\"Sample customer fields:\", Object.keys(customerData[0]));\n\n        // Check for all IVP-related fields\n        const ivpFields = Object.keys(customerData[0]).filter((key) =>\n          key.toLowerCase().includes(\"ivp\"),\n        );\n        console.log(\"IVP-related field names found:\", ivpFields);\n\n        // Log values of IVP fields\n        ivpFields.forEach((field) => {\n          console.log(`Sample ${field}:`, customerData[0][field]);\n        });\n\n        // Also check specifically for the fields we're looking for\n        console.log(\"Sample ivp_region_name:\", customerData[0].ivp_region_name);\n        console.log(\"Sample ivp_inbound_uri:\", customerData[0].ivp_inbound_uri);\n        console.log(\n          \"Sample ivp_outbound_uri:\",\n          customerData[0].ivp_outbound_uri,\n        );\n        console.log(\n          \"Sample ivp_svccarriages:\",\n          customerData[0].ivp_svccarriages,\n        );\n      }\n\n      // Filter for IVP customers (those with \"Region Name\" field)\n      const ivpCustomersAll = customerData.filter(\n        (c) => c[\"Region Name\"] && c.account_no,\n      );\n\n      // Deduplicate by account_no to avoid duplicate services\n      const seenAccounts = new Set();\n      const ivpCustomers = ivpCustomersAll.filter((c) => {\n        if (seenAccounts.has(c.account_no)) {\n          return false;\n        }\n        seenAccounts.add(c.account_no);\n        return true;\n      });\n\n      console.log(\"IVP records found (deduplicated):\", ivpCustomers.length);\n\n      // If no IVP customers found, check for truthy \"Region Name\" values\n      if (ivpCustomers.length === 0) {\n        const customersWithIvpRegion = customerData.filter(\n          (c) => c[\"Region Name\"],\n        );\n        console.log(\n          'Customers with \"Region Name\" (any value):',\n          customersWithIvpRegion.length,\n        );\n        if (customersWithIvpRegion.length > 0) {\n          console.log(\n            'Sample \"Region Name\" values:',\n            customersWithIvpRegion.slice(0, 3).map((c) => c[\"Region Name\"]),\n          );\n        }\n      }\n\n      if (ivpCustomers.length === 0) {\n        console.log(\n          \"No IVP customers to display - checking for null/undefined ivp_region_name\",\n        );\n        return customerNodes;\n      }\n\n      // Get IVP services lookup data from model\n      const ivpServicesLookup =\n        typeof appsmith !== \"undefined\" && appsmith.model?.ivpServices\n          ? appsmith.model.ivpServices\n          : [];\n\n      console.log(`IVP Services lookup data available: ${ivpServicesLookup.length} records`);\n\n      // First, count total number of IVP service nodes to calculate centering\n      // Build array of all services by matching externalid\n      let allServices = [];\n      ivpCustomers.forEach((customer) => {\n        const externalId = customer.ivp_externalid;\n        if (!externalId) return;\n\n        // Find all services for this customer by externalid\n        const customerServices = ivpServicesLookup.filter(\n          (svc) => svc.externalid === externalId\n        );\n\n        // Sort services by Region Name (AU1 first, then AU2)\n        customerServices.sort((a, b) => {\n          const regionA = a[\"Region Name\"] || \"\";\n          const regionB = b[\"Region Name\"] || \"\";\n          if (regionA === regionB) return 0;\n          if (regionA === \"AU1\") return -1;\n          if (regionB === \"AU1\") return 1;\n          return regionA.localeCompare(regionB);\n        });\n\n        allServices.push({\n          customer: customer,\n          services: customerServices,\n        });\n      });\n\n      const totalServiceCount = allServices.reduce(\n        (sum, item) => sum + item.services.length,\n        0\n      );\n\n      // Calculate vertical centering based on IVP Cloud container\n      // IVP Cloud container (group-9) absolute position and size\n      const ivpCloudY = -259.73;\n      const ivpCloudHeight = 239;\n      const ivpCloudCenter = ivpCloudY + (ivpCloudHeight / 2);\n\n      const nodeHeight = 120;\n      const nodeSpacing = 130; // Spacing between node positions (120px node + 10px gap)\n\n      // Calculate the span from first node top to last node bottom\n      // First to last node position span: (N-1) * spacing\n      // Plus the height of the last node: + nodeHeight\n      // Total span = (N-1) * spacing + nodeHeight\n      const totalSpan = (totalServiceCount - 1) * nodeSpacing + nodeHeight;\n\n      // Center the block of nodes at the IVP Cloud center\n      // Top of first node = ivpCloudCenter - (totalSpan / 2)\n      const centerOffset = ivpCloudCenter - (totalSpan / 2);\n\n      console.log(`IVP Cloud Y: ${ivpCloudY}, Height: ${ivpCloudHeight}, Center: ${ivpCloudCenter}`);\n\n      console.log(\n        `Total IVP service nodes: ${totalServiceCount}, center offset: ${centerOffset}, IVP Cloud center: ${ivpCloudCenter}`,\n      );\n\n      // Create separate nodes for each IVP service from ivpServices\n      let nodeCounter = 0;\n\n      allServices.forEach((item) => {\n        const customer = item.customer;\n        const services = item.services;\n\n        console.log(\n          `Processing IVP customer: ${customer.customer} (${customer.account_no})`,\n        );\n        console.log(`  External ID: ${customer.ivp_externalid}`);\n        console.log(`  Found ${services.length} services in ivpServices lookup`);\n\n        // Parse ivp_svcSIP to get profile labels for each service\n        let svcSIPData = [];\n        if (customer.ivp_svcSIP) {\n          try {\n            const svcSIP = JSON.parse(customer.ivp_svcSIP);\n            if (Array.isArray(svcSIP)) {\n              svcSIPData = svcSIP;\n            }\n          } catch (e) {\n            console.error(\"Error parsing ivp_svcSIP:\", e);\n          }\n        }\n\n        // Create a node for each service from ivpServices\n        services.forEach((service, index) => {\n          const serviceName = service[\"Service name\"] || \"N/A\";\n          const inboundUri = service[\"Inbound server/uri\"] || \"N/A\";\n\n          // Find matching profile label from ivp_svcSIP\n          let profileLabel = \"\";\n          const matchingSvc = svcSIPData.find((svc) => svc.name === serviceName);\n          if (matchingSvc && matchingSvc.profile) {\n            profileLabel = matchingSvc.profile.label || \"\";\n          }\n\n          // Use index-based ID to match edge generation\n          const nodeId = `ivp-customer-${customer.account_no}-${index}`;\n\n          console.log(\n            `  Creating IVP node: ${serviceName} | Profile: ${profileLabel} | Inbound: ${inboundUri}`,\n          );\n\n          customerNodes.push({\n            id: nodeId,\n            type: \"custom\",\n            data: {\n              label: `${customer.customer}\\n${serviceName}\\n${profileLabel}\\n${inboundUri}`,\n            },\n            position: {\n              x: 1000,\n              y: centerOffset + nodeCounter * nodeSpacing,\n            },\n            style: {\n              width: 350,\n              height: 120, // Taller for 4 lines of text\n              backgroundColor: \"#dbeafe\", // Light blue for IVP\n            },\n          });\n\n          nodeCounter++;\n        });\n      });\n\n      console.log(\"IVP customer nodes created:\", customerNodes.length);\n      return customerNodes;\n    }\n\n    /* HELPER: Generate Gen1 Customer Nodes from appsmith data */\n    function generateGen1CustomerNodes() {\n      const customerNodes = [];\n\n      // Get customer data from appsmith model or use empty array\n      const customerData =\n        typeof appsmith !== \"undefined\" && appsmith.model?.customerData\n          ? appsmith.model.customerData\n          : [];\n\n      console.log(\"=== Gen1 Customer Data ===\");\n      console.log(\"Total records:\", customerData.length);\n      console.log(\"Sample record:\", customerData[0]);\n\n      // Filter for Gen1 customers (those with data_source field)\n      const gen1Customers = customerData.filter(\n        (c) => c.data_source && c.account_no,\n      );\n\n      console.log(\"Gen1 records found:\", gen1Customers.length);\n\n      if (gen1Customers.length === 0) {\n        console.log(\"No Gen1 customers to display\");\n        return customerNodes;\n      }\n\n      // Group by account number to avoid duplicates\n      // Since the dropdown filters to one account, this will typically be one customer\n      const uniqueCustomers = {};\n      gen1Customers.forEach((customer) => {\n        if (!uniqueCustomers[customer.account_no]) {\n          uniqueCustomers[customer.account_no] = customer;\n        }\n      });\n\n      console.log(\n        \"Unique Gen1 customers:\",\n        Object.keys(uniqueCustomers).length,\n      );\n\n      // Create nodes for each unique Gen1 customer\n      let yOffset = 250; // Start 150px lower (was 100, now 250)\n      Object.values(uniqueCustomers).forEach((customer, index) => {\n        const nodeId = `gen1-customer-${customer.account_no}`;\n\n        // Log what we're creating\n        console.log(\n          `Creating node for: ${customer.customer} (${customer.account_no})`,\n        );\n\n        customerNodes.push({\n          id: nodeId,\n          type: \"custom\",\n          data: {\n            label: `${customer.customer}\\nAccount: ${customer.account_no}`,\n          },\n          position: {\n            x: 1000, // Move 100px to the right (was 900, now 1000)\n            y: yOffset + index * 120,\n          },\n          style: {\n            width: 250,\n            height: 80,\n            backgroundColor: \"#e0f2fe\",\n          },\n        });\n      });\n\n      console.log(\"Customer nodes created:\", customerNodes.length);\n      return customerNodes;\n    }\n\n    /* HELPER: Generate edges for Gen1 Carriage to IVP Carriage (backbone trunks) */\n    function generateIVPCarriageEdges() {\n      const carriageEdges = [];\n\n      // Get customer data from appsmith model or use empty array\n      const customerData =\n        typeof appsmith !== \"undefined\" && appsmith.model?.customerData\n          ? appsmith.model.customerData\n          : [];\n\n      // Backbone trunk names (show between DataCentres and IVP Cloud)\n      const backboneTrunks = [\n        \"AU2 - SYD2 Gen1\",\n        \"AU2- SYD1 GEN1\",\n        \"AU1- SYD1 GEN1\",\n        \"AU1- SYD2 GEN1\",\n      ];\n\n      // Collect backbone trunks and regular carriers from customer data\n      // Also track which regions have carriers\n      const foundBackboneTrunks = new Set();\n      const foundCarriers = new Set();\n      const regionsWithCarriers = new Set();\n\n      customerData.forEach((customer) => {\n        // Only process if customer has both ivp_svccarriages AND Region Name\n        if (customer.ivp_svccarriages && customer[\"Region Name\"]) {\n          try {\n            // Parse JSON array\n            const carriages = JSON.parse(customer.ivp_svccarriages);\n            if (Array.isArray(carriages) && carriages.length > 0) {\n              // Parse Region Name to get individual regions\n              const regionNames = customer[\"Region Name\"]\n                .split(\",\")\n                .map((r) => r.trim())\n                .filter((r) => r);\n\n              // Add regions to set\n              regionNames.forEach((region) => regionsWithCarriers.add(region));\n\n              carriages.forEach((carriage) => {\n                const name = carriage.name;\n                if (name) {\n                  if (backboneTrunks.includes(name)) {\n                    foundBackboneTrunks.add(name);\n                  } else {\n                    foundCarriers.add(name);\n                  }\n                }\n              });\n            }\n          } catch (e) {\n            console.error(\"Error parsing ivp_svccarriages:\", e);\n          }\n        }\n      });\n\n      console.log(\n        \"IVP Backbone Trunks found:\",\n        Array.from(foundBackboneTrunks),\n      );\n      console.log(\"IVP Carriers found:\", Array.from(foundCarriers));\n      console.log(\"Regions with carriers:\", Array.from(regionsWithCarriers));\n\n      // Create edges from DataCentres group to IVP Cloud group for backbone trunks\n      if (foundBackboneTrunks.size > 0) {\n        const trunksLabel = Array.from(foundBackboneTrunks).join(\", \");\n\n        console.log(\n          `Creating DataCentres->IVP Cloud edge with trunks: ${trunksLabel}`,\n        );\n\n        carriageEdges.push({\n          id: `reactflow__edge-group-18bottom-source-group-9top`,\n          source: \"group-9\", // IVP Cloud group\n          target: \"group-18\", // DataCentres group\n          sourceHandle: \"bottom-source\",\n          targetHandle: \"top\",\n          style: {\n            stroke: \"#ef4444\",\n            strokeWidth: 4,\n            strokeDasharray: \"5,5\",\n          },\n          label: trunksLabel,\n        });\n      }\n\n      // Create edges from IVP Carriage (node 2) to AU nodes for regular carriers\n      // Only create edges to regions that actually have carriers\n      if (foundCarriers.size > 0 && regionsWithCarriers.size > 0) {\n        const carriersLabel = Array.from(foundCarriers).join(\", \");\n\n        console.log(\n          `Creating IVP Carriage->AU edges with carriers: ${carriersLabel}`,\n        );\n\n        // Map region names to AU node IDs\n        const regionToNodeId = {\n          AU1: \"13\",\n          AU2: \"14\",\n        };\n\n        // Create edges only to regions that have carriers\n        regionsWithCarriers.forEach((region) => {\n          const auNodeId = regionToNodeId[region];\n          if (auNodeId) {\n            console.log(`  Creating edge to ${region} (${auNodeId})`);\n            carriageEdges.push({\n              id: `reactflow__edge-2right-source-${auNodeId}left-carriers`,\n              source: \"2\", // IVP Carriage node\n              target: auNodeId,\n              sourceHandle: \"right-source\",\n              targetHandle: \"left\",\n              type: \"carrierConnection\",\n              style: {\n                strokeWidth: 1.5,\n                stroke: \"#10b981\",\n              },\n              data: {\n                label: carriersLabel,\n                maxWidth: 200,\n              },\n            });\n          }\n        });\n      }\n\n      console.log(\"IVP Carriage edges created:\", carriageEdges.length);\n      return carriageEdges;\n    }\n\n    /* HELPER: Generate edges for IVP Cloud to IVP Customers */\n    function generateIVPCustomerEdges() {\n      const customerEdges = [];\n\n      // Get customer data from appsmith model or use empty array\n      const customerData =\n        typeof appsmith !== \"undefined\" && appsmith.model?.customerData\n          ? appsmith.model.customerData\n          : [];\n\n      // Filter for IVP customers and deduplicate by account_no\n      const ivpCustomersAll = customerData.filter(\n        (c) => c[\"Region Name\"] && c.account_no,\n      );\n\n      const seenAccounts = new Set();\n      const ivpCustomers = ivpCustomersAll.filter((c) => {\n        if (seenAccounts.has(c.account_no)) {\n          return false;\n        }\n        seenAccounts.add(c.account_no);\n        return true;\n      });\n\n      // Map region names to AU node IDs\n      const regionToNodeId = {\n        AU1: \"13\",\n        AU2: \"14\",\n      };\n\n      console.log(\"=== Generating IVP Customer Edges ===\");\n\n      // Get IVP services lookup data from model\n      const ivpServicesLookup =\n        typeof appsmith !== \"undefined\" && appsmith.model?.ivpServices\n          ? appsmith.model.ivpServices\n          : [];\n\n      console.log(`IVP Services lookup data available: ${ivpServicesLookup.length} records`);\n\n      // Process each customer and create edges for each service from ivpServices\n      ivpCustomers.forEach((customer) => {\n        const externalId = customer.ivp_externalid;\n\n        console.log(`Processing IVP customer edge: ${customer.customer}`);\n        console.log(`  External ID: ${externalId}`);\n\n        if (!externalId) {\n          console.warn(`  No external ID found for customer ${customer.customer}`);\n          return;\n        }\n\n        // Find all services for this customer by externalid\n        const customerServices = ivpServicesLookup.filter(\n          (svc) => svc.externalid === externalId\n        );\n\n        // Sort services by Region Name (AU1 first, then AU2) to match node generation\n        customerServices.sort((a, b) => {\n          const regionA = a[\"Region Name\"] || \"\";\n          const regionB = b[\"Region Name\"] || \"\";\n          if (regionA === regionB) return 0;\n          if (regionA === \"AU1\") return -1;\n          if (regionB === \"AU1\") return 1;\n          return regionA.localeCompare(regionB);\n        });\n\n        console.log(`  Found ${customerServices.length} services in ivpServices lookup`);\n\n        // Create an edge for each service\n        customerServices.forEach((service, index) => {\n          const serviceName = service[\"Service name\"] || \"N/A\";\n          const regionName = service[\"Region Name\"];\n          const outboundUri = service[\"Outbound server/uri\"] || \"N/A\";\n\n          const customerNodeId = `ivp-customer-${customer.account_no}-${index}`;\n          const auNodeId = regionToNodeId[regionName];\n\n          if (!auNodeId) {\n            console.warn(`  No AU node found for region \"${regionName}\"`);\n            return;\n          }\n\n          const auName = auNodeId === \"13\" ? \"AU1\" : \"AU2\";\n          console.log(\n            `  Creating edge: ${auName} (${auNodeId}) -> ${serviceName} (${customerNodeId}) | URI: ${outboundUri}`,\n          );\n\n          customerEdges.push({\n            id: `reactflow__edge-${auNodeId}right-source-${customerNodeId}left-${index}`,\n            source: auNodeId,\n            target: customerNodeId,\n            sourceHandle: \"right-source\",\n            targetHandle: \"left\",\n            type: \"carrierConnection\",\n            style: {\n              strokeWidth: 1.5,\n              stroke: \"#f97316\",\n            },\n            data: {\n              label: outboundUri,\n              maxWidth: 300,\n            },\n          });\n        });\n      });\n\n      console.log(\"IVP Customer edges created:\", customerEdges.length);\n      return customerEdges;\n    }\n\n    /* HELPER: Generate edges for Gen1 Carriage to Data Centers */\n    function generateGen1CarriageEdges() {\n      const carriageEdges = [];\n\n      // Get customer data from appsmith model or use empty array\n      const customerData =\n        typeof appsmith !== \"undefined\" && appsmith.model?.customerData\n          ? appsmith.model.customerData\n          : [];\n\n      // Map data_source to node IDs\n      const dataSourceToNodeId = {\n        SYD1A: \"19\",\n        SYD2A: \"21\",\n        SEMA: \"20\",\n      };\n\n      // Collect carrier connections by data source\n      const carriersByDataSource = {};\n      customerData.forEach((customer) => {\n        if (customer.data_source && customer.carrier_connections) {\n          const dataSource = customer.data_source;\n          if (!carriersByDataSource[dataSource]) {\n            carriersByDataSource[dataSource] = new Set();\n          }\n          // Split carrier connections and add to set\n          const carriers = customer.carrier_connections\n            .split(\",\")\n            .map((c) => c.trim());\n          carriers.forEach((carrier) => {\n            if (carrier) carriersByDataSource[dataSource].add(carrier);\n          });\n        }\n      });\n\n      // Create edges from Gen1 Carriage to data centers\n      Object.keys(carriersByDataSource).forEach((dataSource) => {\n        const dataNodeId = dataSourceToNodeId[dataSource];\n        if (dataNodeId) {\n          const carriers = Array.from(carriersByDataSource[dataSource]).join(\n            \", \",\n          );\n\n          carriageEdges.push({\n            id: `reactflow__edge-1right-source-${dataNodeId}left`,\n            source: \"1\", // Gen1 Carriage node\n            target: dataNodeId,\n            sourceHandle: \"right-source\",\n            targetHandle: \"left\",\n            type: \"carrierConnection\",\n            style: {\n              strokeWidth: 1.5,\n              stroke: \"#10b981\",\n            },\n            data: {\n              label: carriers,\n              maxWidth: 200,\n            },\n          });\n        }\n      });\n\n      console.log(\"Gen1 Carriage edges created:\", carriageEdges.length);\n      return carriageEdges;\n    }\n\n    /* HELPER: Generate edges for Gen1 Customers to Data Centers */\n    function generateGen1CustomerEdges() {\n      const customerEdges = [];\n\n      // Get customer data from appsmith model or use empty array\n      const customerData =\n        typeof appsmith !== \"undefined\" && appsmith.model?.customerData\n          ? appsmith.model.customerData\n          : [];\n\n      // Filter for Gen1 customers (those with data_source field)\n      const gen1Customers = customerData.filter(\n        (c) => c.data_source && c.account_no,\n      );\n\n      // Map data_source values to node IDs\n      const dataSourceToNodeId = {\n        SYD1A: \"19\", // SYD1 node\n        SYD2A: \"21\", // SYD2 node\n        SEMA: \"20\", // SEMA node\n      };\n\n      // Group by account number and data source to collect connection details\n      const customerConnections = {};\n      gen1Customers.forEach((customer) => {\n        const accountNo = customer.account_no;\n        const dataSource = customer.data_source;\n\n        if (!dataSource || !dataSourceToNodeId[dataSource]) return;\n\n        const connectionKey = `${accountNo}-${dataSource}`;\n        if (!customerConnections[connectionKey]) {\n          customerConnections[connectionKey] = {\n            accountNo: accountNo,\n            dataSource: dataSource,\n            sourceRealm: customer.source_realm || \"N/A\",\n            sessionAgents: customer.customer_realm_session_agents || \"N/A\",\n            genesysDomains: customer.genesys_purecloud_domains || \"\", // Blank instead of N/A\n          };\n        }\n      });\n\n      // Create edges from data centers to customer nodes\n      Object.values(customerConnections).forEach((connection) => {\n        const customerNodeId = `gen1-customer-${connection.accountNo}`;\n        const dataNodeId = dataSourceToNodeId[connection.dataSource];\n\n        if (dataNodeId) {\n          // Check if all data is N/A or empty - skip edge if so\n          const hasValidData =\n            connection.sourceRealm !== \"N/A\" ||\n            connection.sessionAgents !== \"N/A\" ||\n            (connection.genesysDomains && connection.genesysDomains !== \"\");\n\n          if (!hasValidData) {\n            console.log(\n              `Skipping edge for ${connection.accountNo} - ${connection.dataSource}: all data is N/A or empty`,\n            );\n            return; // Skip this edge\n          }\n\n          // Build label lines\n          const labelLines = {\n            line1: `source_realm: ${connection.sourceRealm}`,\n            line2: `Session Agents: ${connection.sessionAgents}`,\n            line3: \"\", // Will be set below if there's a Genesys domain\n          };\n\n          // Add Genesys domain on separate line if it exists\n          if (\n            connection.genesysDomains &&\n            connection.genesysDomains.trim() !== \"\"\n          ) {\n            labelLines.line3 = connection.genesysDomains;\n          }\n\n          // Create edge with custom data for multi-line label\n          customerEdges.push({\n            id: `reactflow__edge-${dataNodeId}right-source-${customerNodeId}left`,\n            source: dataNodeId,\n            target: customerNodeId,\n            sourceHandle: \"right-source\",\n            targetHandle: \"left\",\n            type: \"custom\",\n            style: {\n              strokeWidth: 1.5,\n              stroke: \"#f97316\",\n            },\n            data: {\n              label: labelLines,\n            },\n          });\n        }\n      });\n\n      console.log(\"Customer edges created:\", customerEdges.length);\n      return customerEdges;\n    }\n\n    /* DATA: Initial nodes from dataTopoV1 export */\n    const baseNodes = [\n      {\n        id: \"1\",\n        type: \"custom\",\n        data: {\n          label: \"Gen1 Carriage\",\n        },\n        position: {\n          x: -92.23607459514959,\n          y: 254.45662088626688,\n        },\n        style: {\n          width: 150,\n          height: 60,\n          backgroundColor: \"#ffffff\",\n        },\n      },\n      {\n        id: \"2\",\n        type: \"custom\",\n        data: {\n          label: \"IVP Carriage\",\n        },\n        position: {\n          x: -106.585126130654658,\n          y: -163.33815637366678,\n        },\n        style: {\n          width: 150,\n          height: 60,\n          backgroundColor: \"#ffffff\",\n        },\n      },\n      {\n        id: \"group-9\",\n        type: \"customGroup\",\n        data: {\n          label: \"IVP Cloud\",\n        },\n        position: {\n          x: 290.0499501427992,\n          y: -259.72884777726097,\n        },\n        style: {\n          width: 255,\n          height: 239,\n        },\n      },\n      {\n        id: \"13\",\n        type: \"custom\",\n        data: {\n          label: \"AU1\",\n        },\n        position: {\n          x: 15.433429384550266,\n          y: 52.558069192486755,\n        },\n        parentNode: \"group-9\",\n        extent: \"parent\",\n        style: {\n          width: 217,\n          height: 62,\n          backgroundColor: \"#ffffff\",\n        },\n      },\n      {\n        id: \"14\",\n        type: \"custom\",\n        data: {\n          label: \"AU2\",\n        },\n        position: {\n          x: 14.291786730687818,\n          y: 147.31440946306867,\n        },\n        parentNode: \"group-9\",\n        extent: \"parent\",\n        style: {\n          width: 220,\n          height: 60,\n          backgroundColor: \"#ffffff\",\n        },\n      },\n      {\n        id: \"group-18\",\n        type: \"customGroup\",\n        data: {\n          label: \"DataCentres\",\n        },\n        position: {\n          x: 292.71345699905817,\n          y: 103.65544196480488,\n        },\n        style: {\n          width: 247,\n          height: 346,\n        },\n      },\n      {\n        id: \"19\",\n        type: \"custom\",\n        data: {\n          label: \"SYD1\",\n        },\n        position: {\n          x: 24.16259636112767,\n          y: 48.32519272225525,\n        },\n        parentNode: \"group-18\",\n        extent: \"parent\",\n        style: {\n          width: 204,\n          height: 50,\n          backgroundColor: \"#ffffff\",\n        },\n      },\n      {\n        id: \"20\",\n        type: \"custom\",\n        data: {\n          label: \"SEMA\",\n        },\n        position: {\n          x: 76.24149643709859,\n          y: 159.51681709290574,\n        },\n        parentNode: \"group-18\",\n        extent: \"parent\",\n        style: {\n          width: 100,\n          height: 50,\n          backgroundColor: \"#ffffff\",\n        },\n      },\n      {\n        id: \"21\",\n        type: \"custom\",\n        data: {\n          label: \"SYD2\",\n        },\n        position: {\n          x: 24.6304399893541,\n          y: 271.2658757959249,\n        },\n        parentNode: \"group-18\",\n        extent: \"parent\",\n        style: {\n          width: 202,\n          height: 50,\n          backgroundColor: \"#ffffff\",\n        },\n      },\n    ];\n\n    // Enhance base nodes with dynamic data\n    let enhancedNodes = enhanceDataCentreNodes(baseNodes);\n    enhancedNodes = updateLocalPolicyNodes(enhancedNodes);\n\n    // Combine enhanced base nodes with generated customer nodes\n    const ivpCustomerNodes = generateIVPCustomerNodes();\n    const gen1CustomerNodes = generateGen1CustomerNodes();\n\n    // Check if customer has any IVP or Gen1 services\n    const hasIVPServices = ivpCustomerNodes.length > 0;\n    const hasGen1Services = gen1CustomerNodes.length > 0;\n\n    console.log(`Customer has IVP services: ${hasIVPServices}`);\n    console.log(`Customer has Gen1 services: ${hasGen1Services}`);\n\n    // Filter base nodes based on service availability\n    const filteredBaseNodes = enhancedNodes.filter((node) => {\n      // IVP related nodes: 2 (IVP Carriage), group-9 (IVP Cloud), 13 (AU1), 14 (AU2)\n      const isIVPNode = [\"2\", \"group-9\", \"13\", \"14\"].includes(node.id);\n      if (isIVPNode && !hasIVPServices) {\n        console.log(`Filtering out IVP node: ${node.id} (${node.data?.label})`);\n        return false;\n      }\n\n      // Gen1 related nodes: 1 (Gen1 Carriage), group-18 (DataCentres), 19 (SYD1), 20 (SEMA), 21 (SYD2)\n      const isGen1Node = [\"1\", \"group-18\", \"19\", \"20\", \"21\"].includes(node.id);\n      if (isGen1Node && !hasGen1Services) {\n        console.log(`Filtering out Gen1 node: ${node.id} (${node.data?.label})`);\n        return false;\n      }\n\n      return true;\n    });\n\n    const initialNodes = [\n      ...filteredBaseNodes,\n      ...ivpCustomerNodes,\n      ...gen1CustomerNodes,\n    ];\n\n    console.log(\n      \"Total nodes:\",\n      initialNodes.length,\n      \"(Base:\",\n      baseNodes.length,\n      \"+ IVP Customers:\",\n      ivpCustomerNodes.length,\n      \"+ Gen1 Customers:\",\n      gen1CustomerNodes.length,\n      \")\",\n    );\n\n    /* DATA: Initial edges from dataTopoV1 export */\n    const baseEdges = [\n      {\n        id: \"reactflow__edge-19left-source-20left\",\n        source: \"19\",\n        target: \"20\",\n        sourceHandle: \"left-source\",\n        targetHandle: \"left\",\n        style: {\n          stroke: \"#ef4444\",\n          strokeDasharray: \"5,5\",\n        },\n        label: \"Dirty\",\n      },\n      {\n        id: \"reactflow__edge-21left-source-20left\",\n        source: \"21\",\n        target: \"20\",\n        sourceHandle: \"left-source\",\n        targetHandle: \"left\",\n        style: {\n          stroke: \"#ef4444\",\n          strokeDasharray: \"5,5\",\n        },\n        label: \"Dirty\",\n      },\n      {\n        id: \"reactflow__edge-20top-source-19bottom\",\n        source: \"20\",\n        target: \"19\",\n        sourceHandle: \"top-source\",\n        targetHandle: \"bottom\",\n        style: {\n          stroke: \"#10b981\",\n          strokeDasharray: \"5,5\",\n        },\n        label: \"Clean\",\n      },\n      {\n        id: \"reactflow__edge-20bottom-source-21top\",\n        source: \"20\",\n        target: \"21\",\n        sourceHandle: \"bottom-source\",\n        targetHandle: \"top\",\n        style: {\n          stroke: \"#10b981\",\n          strokeDasharray: \"5,5\",\n        },\n        label: \"Clean\",\n      },\n    ];\n\n    // Check if customer uses SEMA payments to filter edges\n    const customerData =\n      typeof appsmith !== \"undefined\" && appsmith.model?.customerData\n        ? appsmith.model.customerData\n        : [];\n    const usesSemaPayments = customerData.some(\n      (customer) =>\n        customer.uses_sema_payments === true ||\n        customer.uses_sema_payments === \"true\",\n    );\n\n    // Filter base edges to remove SEMA connections if not using SEMA payments\n    const filteredBaseEdges = usesSemaPayments\n      ? baseEdges\n      : baseEdges.filter((edge) => {\n          // Remove edges that involve SEMA node (ID '20')\n          const isSemaEdge = edge.source === \"20\" || edge.target === \"20\";\n          return !isSemaEdge;\n        });\n\n    console.log(\n      \"Filtered SEMA edges:\",\n      !usesSemaPayments,\n      \"- Removed\",\n      baseEdges.length - filteredBaseEdges.length,\n      \"edges\",\n    );\n\n    // Generate and combine all dynamic edges\n    const ivpCarriageEdges = generateIVPCarriageEdges();\n    const ivpCustomerEdges = generateIVPCustomerEdges();\n    const gen1CarriageEdges = generateGen1CarriageEdges();\n    const gen1CustomerEdges = generateGen1CustomerEdges();\n    const initialEdges = [\n      ...filteredBaseEdges,\n      ...ivpCarriageEdges,\n      ...ivpCustomerEdges,\n      ...gen1CarriageEdges,\n      ...gen1CustomerEdges,\n    ];\n\n    console.log(\n      \"Total edges:\",\n      initialEdges.length,\n      \"(Base:\",\n      filteredBaseEdges.length,\n      \"+ IVP Carriage:\",\n      ivpCarriageEdges.length,\n      \"+ IVP Customer:\",\n      ivpCustomerEdges.length,\n      \"+ Gen1 Carriage:\",\n      gen1CarriageEdges.length,\n      \"+ Gen1 Customer:\",\n      gen1CustomerEdges.length,\n      \")\",\n    );\n\n    /* ====================================================================\n     * REACT FLOW COMPONENT\n     * ====================================================================\n     */\n\n    /* COMPONENT 5: Main Network Topology Component */\n    const NetworkTopology = () => {\n      // State for nodes and edges\n      const [nodes, setNodes] = React.useState(initialNodes);\n      const [edges, setEdges] = React.useState(initialEdges);\n\n      // Node types registry - must be memoized to prevent re-creation on each render\n      const nodeTypes = React.useMemo(\n        () => ({\n          custom: CustomNode,\n          customGroup: CustomGroupNode,\n          customText: CustomTextNode,\n        }),\n        [],\n      );\n\n      // Edge types registry - must be memoized to prevent re-creation on each render\n      const edgeTypes = React.useMemo(\n        () => ({\n          custom: CustomEdge,\n          carrierConnection: CarrierConnectionEdge,\n        }),\n        [],\n      );\n\n      console.log(\n        \"Rendering ReactFlow with\",\n        nodes.length,\n        \"nodes and\",\n        edges.length,\n        \"edges\",\n      );\n\n      // Expose update function globally so appsmith.onModelChange can call it\n      React.useEffect(() => {\n        window.updateTopology = () => {\n          console.log(\"Updating topology with new customer data...\");\n\n          // Check if customer uses SEMA payments\n          const updatedCustomerData =\n            typeof appsmith !== \"undefined\" && appsmith.model?.customerData\n              ? appsmith.model.customerData\n              : [];\n          const updatedUsesSemaPayments = updatedCustomerData.some(\n            (customer) =>\n              customer.uses_sema_payments === true ||\n              customer.uses_sema_payments === \"true\",\n          );\n\n          // Regenerate and enhance base nodes\n          let newEnhancedNodes = enhanceDataCentreNodes(baseNodes);\n          newEnhancedNodes = updateLocalPolicyNodes(newEnhancedNodes);\n\n          // Regenerate customer nodes\n          const newIVPCustomerNodes = generateIVPCustomerNodes();\n          const newGen1CustomerNodes = generateGen1CustomerNodes();\n\n          // Check if customer has any IVP or Gen1 services\n          const newHasIVPServices = newIVPCustomerNodes.length > 0;\n          const newHasGen1Services = newGen1CustomerNodes.length > 0;\n\n          console.log(`Customer has IVP services: ${newHasIVPServices}`);\n          console.log(`Customer has Gen1 services: ${newHasGen1Services}`);\n\n          // Filter base nodes based on service availability\n          const newFilteredBaseNodes = newEnhancedNodes.filter((node) => {\n            // IVP related nodes: 2 (IVP Carriage), group-9 (IVP Cloud), 13 (AU1), 14 (AU2)\n            const isIVPNode = [\"2\", \"group-9\", \"13\", \"14\"].includes(node.id);\n            if (isIVPNode && !newHasIVPServices) {\n              return false;\n            }\n\n            // Gen1 related nodes: 1 (Gen1 Carriage), group-18 (DataCentres), 19 (SYD1), 20 (SEMA), 21 (SYD2)\n            const isGen1Node = [\"1\", \"group-18\", \"19\", \"20\", \"21\"].includes(node.id);\n            if (isGen1Node && !newHasGen1Services) {\n              return false;\n            }\n\n            return true;\n          });\n\n          const newNodes = [\n            ...newFilteredBaseNodes,\n            ...newIVPCustomerNodes,\n            ...newGen1CustomerNodes,\n          ];\n\n          // Filter base edges to remove SEMA connections if not using SEMA payments\n          const newFilteredBaseEdges = updatedUsesSemaPayments\n            ? baseEdges\n            : baseEdges.filter((edge) => {\n                const isSemaEdge = edge.source === \"20\" || edge.target === \"20\";\n                return !isSemaEdge;\n              });\n\n          // Regenerate edges\n          const newIVPCarriageEdges = generateIVPCarriageEdges();\n          const newIVPCustomerEdges = generateIVPCustomerEdges();\n          const newGen1CarriageEdges = generateGen1CarriageEdges();\n          const newGen1CustomerEdges = generateGen1CustomerEdges();\n          const newEdges = [\n            ...newFilteredBaseEdges,\n            ...newIVPCarriageEdges,\n            ...newIVPCustomerEdges,\n            ...newGen1CarriageEdges,\n            ...newGen1CustomerEdges,\n          ];\n\n          console.log(\n            \"New topology generated:\",\n            newNodes.length,\n            \"nodes,\",\n            newEdges.length,\n            \"edges\",\n          );\n          console.log(\"SEMA edges filtered:\", !updatedUsesSemaPayments);\n\n          // Update state\n          setNodes(newNodes);\n          setEdges(newEdges);\n        };\n      }, []);\n\n      console.log(\n        \"Rendering ReactFlow with nodes:\",\n        nodes.length,\n        \"edges:\",\n        edges.length,\n      );\n      console.log(\"First edge:\", edges[0]);\n\n      return React.createElement(\n        \"div\",\n        { style: { width: \"100%\", height: \"100%\" } },\n        React.createElement(\n          ReactFlow,\n          {\n            nodes,\n            edges,\n            nodeTypes,\n            edgeTypes,\n            fitView: true,\n            fitViewOptions: {\n              padding: 0.2,\n              includeHiddenNodes: false,\n            },\n            minZoom: 0.1,\n            maxZoom: 2,\n            defaultViewport: { x: 0, y: 0, zoom: 0.8 },\n            attributionPosition: \"bottom-left\",\n            onInit: (instance) => {\n              console.log(\"ReactFlow initialized\");\n              console.log(\"Edges in store:\", instance.getEdges().length);\n            },\n          },\n          React.createElement(Controls, {\n            showZoom: true,\n            showFitView: true,\n            showInteractive: true,\n          }),\n          React.createElement(MiniMap, {\n            nodeColor: (node) => {\n              if (node.type === \"customGroup\") return \"rgba(66, 153, 225, 0.3)\";\n              if (node.type === \"customText\") return \"#fffef0\";\n              if (node.style?.backgroundColor)\n                return node.style.backgroundColor;\n              return \"#ffffff\";\n            },\n            maskColor: \"rgba(0, 0, 0, 0.1)\",\n            zoomable: true,\n            pannable: true,\n          }),\n          React.createElement(Background, {\n            variant: \"dots\",\n            gap: 16,\n            size: 1,\n            color: \"#e5e7eb\",\n          }),\n        ),\n      );\n    };\n\n    /* ====================================================================\n     * RENDER TO DOM\n     * ====================================================================\n     */\n\n    console.log(\"âœ“ Custom node components created\");\n    console.log(\"âœ“ Network topology data loaded\");\n\n    // Render the React Flow component\n    const container = document.getElementById(\"root\");\n    if (!container) {\n      throw new Error(\"Root container not found\");\n    }\n\n    const root = ReactDOMClient.createRoot(container);\n\n    // Check if ReactFlowProvider exists\n    if (ReactFlowProvider) {\n      console.log(\"Using ReactFlowProvider to wrap app\");\n      const App = () =>\n        React.createElement(\n          ReactFlowProvider,\n          null,\n          React.createElement(NetworkTopology),\n        );\n      root.render(React.createElement(App));\n    } else {\n      console.log(\"No ReactFlowProvider found, rendering directly\");\n      root.render(React.createElement(NetworkTopology));\n    }\n\n    console.log(\"âœ“ DataTopoV1 Network Topology Rendered Successfully\");\n    console.log(\"ðŸ“Š Nodes:\", initialNodes.length);\n    console.log(\"ðŸ”— Edges:\", initialEdges.length);\n  } catch (error) {\n    console.error(\"âŒ Error initializing network topology:\", error);\n    const container = document.getElementById(\"root\");\n    if (container) {\n      container.innerHTML =\n        '<div class=\"topology-error\">' +\n        \"<h3>Error Loading Network Topology</h3>\" +\n        \"<p><strong>Error:</strong> \" +\n        error.message +\n        \"</p>\" +\n        \"<pre>\" +\n        error.stack +\n        \"</pre>\" +\n        \"</div>\";\n    }\n  }\n}\n\n/* ========================================================================\n * APPSMITH MODEL UPDATE HANDLER\n * ========================================================================\n */\n\n// Listen for model updates from Appsmith\nappsmith.onModelChange(() => {\n  console.log(\"Model data updated:\", appsmith.model);\n\n  // Trigger topology update when customer data changes\n  if (typeof window.updateTopology === \"function\") {\n    window.updateTopology();\n  }\n});\n\n/* ========================================================================\n * UTILITY FUNCTIONS (Optional)\n * ========================================================================\n */\n\n// Helper function to format node data\nfunction formatNodeLabel(data) {\n  if (!data) return \"N/A\";\n  if (typeof data === \"string\") return data;\n  return JSON.stringify(data);\n}\n\n// Helper function to validate edge connections\nfunction isValidConnection(connection) {\n  return connection.source && connection.target;\n}\n\nconsole.log(\"âœ“ DataTopoV1 widget script loaded\");\n"
  },
  "version": 1,
  "widgetId": "w0yrj9tm0d",
  "widgetName": "ReactFlow"
}